{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NonMarkovian methods documentation","text":"<p>Provides a solver class for the Refined Weak Coupling Limit/Cumulant equation  and the \\(TCL_{2}\\) Redfield equation. The solver\u015b here are only valid for Bosonic environments, support for fermionic environmets will come soon. The results for the  Refined Weak Coupling Limit are always in the interaction picture while the ones for Redfield can be in Schrodinder's or interaction picture, it is selected using the picture argument ('S' or 'I').</p> <p>More about the cumulant equation can be found in [1,2,3,4]. The notation used for \\(TCL_{2}\\) can be found in [1,5] We also provide a way to speed up their simulation using approximate environments as described in [2]. The approach in that paper is used when the argument Matsubara is set to True, otherwise numerical integration is used. </p> <p>All the examples in this code require QuTiP, as the methods here are validated using QuTiP's HEOM solver [6,7]. The examples also required QuTiP  the environment class [7].</p> <ol> <li> Su\u00e1rez, G., \u0141obejko, M., Horodecki, M. (2024). Dynamics of the Non-equilibrium spin Boson Model: A Benchmark of master equations and their validity. . This article can be reproduced with the code from example one </li> <li>Su\u00e1rez, G., Horodecki, M. (2025). Making Non-Markovian master equations accessible with approximate environments. The examples in this article can be reproduced with the code from examples 2-5</li> <li>Rivas, \u00c1. (2016). Refined Weak Coupling Limit: Coherence, Entanglement and Non-Markovianity.</li> <li>Winczewski, M., Mandarino, A., Suarez, G., Horodecki, M., Alicki, R. (2021). Intermediate Times Dilemma for Open Quantum System: Filtered Approximation to The Refined Weak Coupling Limit.</li> <li>\u0141obejko, M., Winczewski, M., Su\u00e1rez, G., Alicki, R., Horodecki, M. (2022). Corrections to the Hamiltonian induced by finite-strength coupling to the environment.</li> <li>Lambert, N., Raheja, T., Cross, S., Menczel, P., Ahmed, S., Pitchford, A., Burgarth, D., Nori, F. (2020). QuTiP-BoFiN: A bosonic and fermionic numerical hierarchical-equations-of-motion library with applications in light-harvesting, quantum control, and single-molecule electronics</li> <li>Lambert, N., Gigu\u00e8re, E., Menczel, P., Li, B., Hopf, P., Su\u00e1rez, G., Gali, M., Lishman, J., Gadhvi, R., Agarwal, R., Galicia, A., Shammah, N., Nation, P., Johansson, J.R., Ahmed, S., Cross, S., Pitchford, A., Nori, F. (2024). QuTiP 5: The Quantum Toolbox in Python</li> </ol>"},{"location":"Qubit_example/","title":"Example 2: The Refined Weak Coupling/ Cumulant equation for a spin boson model with an sub-Ohmic spectral density","text":"In\u00a0[1]: Copied! <pre>from nmm import csolve,redfield\nimport numpy as np\nimport qutip as qt\nimport matplotlib.pyplot as plt\nfrom time import time\nimport matplotlib.patheffects as pe\nfrom qutip.core.environment import OhmicEnvironment\n</pre> from nmm import csolve,redfield import numpy as np import qutip as qt import matplotlib.pyplot as plt from time import time import matplotlib.patheffects as pe from qutip.core.environment import OhmicEnvironment <p>We first define our initial state, as well as some auxiliary variables and functions</p> In\u00a0[2]: Copied! <pre>def rotation(data,H, t):\n    try:\n        rotated = [\n            (-1j * H * t[i]).expm()\n            * data[i]\n            * (1j * H * t[i]).expm()\n            for i in range(len(t))\n        ]\n    except:\n        rotated = [\n            (-1j * H * t[i]).expm()\n            * qt.Qobj(data[i],dims=H.dims)\n            * (1j * H * t[i]).expm()\n            for i in range(len(t))\n        ]\n    return rotated\noptions = {'nsteps':150_000, 'store_states':True, 'atol':1e-8, 'rtol':1e-8}\nrho0=qt.Qobj([[1,1],[1,1]])*0.5\n</pre> def rotation(data,H, t):     try:         rotated = [             (-1j * H * t[i]).expm()             * data[i]             * (1j * H * t[i]).expm()             for i in range(len(t))         ]     except:         rotated = [             (-1j * H * t[i]).expm()             * qt.Qobj(data[i],dims=H.dims)             * (1j * H * t[i]).expm()             for i in range(len(t))         ]     return rotated options = {'nsteps':150_000, 'store_states':True, 'atol':1e-8, 'rtol':1e-8} rho0=qt.Qobj([[1,1],[1,1]])*0.5 <p>We then prepare our enviroment, bathr will correspond to the original environment while envfit2 corresponds to one approximated with damped sinusoidals. We used the QuTiP enviroment class  to do this</p> In\u00a0[3]: Copied! <pre>tfit=np.linspace(0,50,2000)\nbathr=OhmicEnvironment(T=0.5,alpha=0.05*np.pi,wc=1,s=3/2)\nenvfit2,fitinfo=bathr.approximate(\"espira-I\",tlist=tfit,Nr=10)\nprint(fitinfo[\"summary\"])\n</pre> tfit=np.linspace(0,50,2000) bathr=OhmicEnvironment(T=0.5,alpha=0.05*np.pi,wc=1,s=3/2) envfit2,fitinfo=bathr.approximate(\"espira-I\",tlist=tfit,Nr=10) print(fitinfo[\"summary\"]) <pre>Result of fitting Correlation Function with 10 terms: \n \n Parameters|   ckr    |   cki    |   vkr    |  vki \n 1         | 1.61e-03 |-5.44e-03 | 6.41e+00 |7.21e+00\n 2         |-6.02e-02 | 1.03e-02 | 4.87e+00 |3.62e+00\n 3         | 1.02e-01 | 1.45e-01 | 3.41e+00 |1.52e+00\n 4         | 2.26e-02 | 1.58e-02 | 2.74e+00 |-9.83e-01\n 5         |-1.25e-02 |-1.30e-01 | 1.99e+00 |3.92e-01\n 6         | 3.26e-02 |-3.75e-02 | 1.42e+00 |1.07e-01\n 7         |-3.03e-03 | 1.28e-03 | 4.17e-01 |-1.25e-02\n 8         |-1.92e-03 | 4.79e-04 | 2.03e-01 |-8.94e-03\n 9         |-8.06e-04 | 1.21e-04 | 8.20e-02 |-4.07e-03\n 10        |-1.90e-04 | 1.81e-05 | 1.94e-02 |-9.94e-04\n \nA RMSE of  2.00e-08-1.21e-08j was obtained for the Correlation Function.\nThe current fit took  6.886337 seconds.\n</pre> <p>We then perfom the simulation, remember that what this package provides is the Redfield and cumulant solvers, while the HEOm solver comes from QuTiP. The solvers allow to turn Lamb-shift on and of with the ls argument. Using exponents to accelerate the simulation of the master equation as explained in 2 can be turned on and off using the matsubara argument. With this in mind we proceed with all the simulations needed to reproduce example 1 from 2</p> In\u00a0[4]: Copied! <pre>k=1\nw=1\nH=k/2 *qt.sigmax()  + w/2 * qt.sigmaz()\nQ=qt.sigmaz()\nt=np.linspace(0,100/bathr.alpha,1500)\nstart=time()\nsolver = qt.solver.heom.HEOMSolver(H,(envfit2,Q), max_depth=3,options=options)\nresult = solver.run(rho0, t,e_ops=[(1+qt.sigmaz())/2,qt.sigmap()])\nend_heom=time()\ncum2=csolve(Hsys=H,t=t,baths=[envfit2],Qs=[Q],cython=False,matsubara=True)\nresult_cum2=cum2.evolution(rho0)\nresult_cum=rotation(result_cum2,H,t)\nend_cum=time()\ncum=csolve(Hsys=H,t=t,baths=[bathr],Qs=[Q],eps=1e-4,cython=False,matsubara=False)\nresult_cum22=cum.evolution(rho0)\nresult_cum21=rotation(result_cum22,H,t)\nend_cum2=time()\ncum2=csolve(Hsys=H,t=t,baths=[envfit2],Qs=[Q],cython=False,matsubara=True,ls=True)\nresult_cum2=cum2.evolution(rho0)\nresult_cum_ls=rotation(result_cum2,H,t)\nend_cum3=time()\nred2=redfield.redfield(Hsys=H,t=t,baths=[envfit2],Qs=[Q],eps=1e-8,matsubara=True,ls=False,picture=\"S\")\nresult_red2=red2.evolution(rho0,method=\"BDF\")\nend_redfield=time()\nred=redfield.redfield(Hsys=H,t=t,baths=[bathr],Qs=[Q],eps=1e-2,matsubara=False,ls=False,picture=\"S\") \n# Eps should be lower, but this slows the simulation quite a bit (and does not impact accuracy to much) the results in the paper \n# used lower eps\nresult_red=red.evolution(rho0,method=\"BDF\")\nend_redfield2=time()\nred=redfield.redfield(Hsys=H,t=t,baths=[envfit2],Qs=[Q],eps=1e-8,matsubara=True,ls=True,picture=\"S\")\nresult_red_ls=red.evolution(rho0)\nend_redfield3=time()\ncops=cum.jump_operators(Q)\ncops=[qt.Qobj((np.sqrt(bathr.power_spectrum(k))*v)) for k, v in cops.items()]\nresult_lindblad_global2 = qt.mesolve(H, rho0, t, cops,options={\"rtol\":1e-12,\"atol\":1e-12})\nend_redfield3=time()\n</pre> k=1 w=1 H=k/2 *qt.sigmax()  + w/2 * qt.sigmaz() Q=qt.sigmaz() t=np.linspace(0,100/bathr.alpha,1500) start=time() solver = qt.solver.heom.HEOMSolver(H,(envfit2,Q), max_depth=3,options=options) result = solver.run(rho0, t,e_ops=[(1+qt.sigmaz())/2,qt.sigmap()]) end_heom=time() cum2=csolve(Hsys=H,t=t,baths=[envfit2],Qs=[Q],cython=False,matsubara=True) result_cum2=cum2.evolution(rho0) result_cum=rotation(result_cum2,H,t) end_cum=time() cum=csolve(Hsys=H,t=t,baths=[bathr],Qs=[Q],eps=1e-4,cython=False,matsubara=False) result_cum22=cum.evolution(rho0) result_cum21=rotation(result_cum22,H,t) end_cum2=time() cum2=csolve(Hsys=H,t=t,baths=[envfit2],Qs=[Q],cython=False,matsubara=True,ls=True) result_cum2=cum2.evolution(rho0) result_cum_ls=rotation(result_cum2,H,t) end_cum3=time() red2=redfield.redfield(Hsys=H,t=t,baths=[envfit2],Qs=[Q],eps=1e-8,matsubara=True,ls=False,picture=\"S\") result_red2=red2.evolution(rho0,method=\"BDF\") end_redfield=time() red=redfield.redfield(Hsys=H,t=t,baths=[bathr],Qs=[Q],eps=1e-2,matsubara=False,ls=False,picture=\"S\")  # Eps should be lower, but this slows the simulation quite a bit (and does not impact accuracy to much) the results in the paper  # used lower eps result_red=red.evolution(rho0,method=\"BDF\") end_redfield2=time() red=redfield.redfield(Hsys=H,t=t,baths=[envfit2],Qs=[Q],eps=1e-8,matsubara=True,ls=True,picture=\"S\") result_red_ls=red.evolution(rho0) end_redfield3=time() cops=cum.jump_operators(Q) cops=[qt.Qobj((np.sqrt(bathr.power_spectrum(k))*v)) for k, v in cops.items()] result_lindblad_global2 = qt.mesolve(H, rho0, t, cops,options={\"rtol\":1e-12,\"atol\":1e-12}) end_redfield3=time() <pre>10.0%. Run time:   1.43s. Est. time left: 00:00:00:12\n20.0%. Run time:   2.91s. Est. time left: 00:00:00:11\n30.0%. Run time:   4.38s. Est. time left: 00:00:00:10\n40.0%. Run time:   5.87s. Est. time left: 00:00:00:08\n50.0%. Run time:   7.35s. Est. time left: 00:00:00:07\n60.0%. Run time:   8.79s. Est. time left: 00:00:00:05\n70.0%. Run time:  10.23s. Est. time left: 00:00:00:04\n80.1%. Run time:  11.67s. Est. time left: 00:00:00:02\n90.1%. Run time:  13.15s. Est. time left: 00:00:00:01\n100.0%. Run time:  14.57s. Est. time left: 00:00:00:00\n</pre> <pre>WARNING:2025-06-29 19:28:30,569:jax._src.xla_bridge:969: An NVIDIA GPU may be present on this machine, but a CUDA-enabled jaxlib is not installed. Falling back to cpu.\n</pre> <pre>Total run time:  14.57s\n</pre> <pre>Calculating Integrals ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:00&lt;00:00, 316.11it/s]\nCalculating time independent matrices...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:00&lt;00:00, 3088.59it/s]\nCalculating time dependent generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:00&lt;00:00, 98.03it/s]\nComputing Exponential of Generators . . . .: 1500it [00:00, 2496.64it/s]\nCalculating Integrals ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:08&lt;00:00,  1.09it/s]\nCalculating time independent matrices...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:00&lt;00:00, 3353.06it/s]\nCalculating time dependent generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:00&lt;00:00, 115.67it/s]\nComputing Exponential of Generators . . . .: 1500it [00:00, 2353.29it/s]\nCalculating Integrals ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:00&lt;00:00, 378.74it/s]\nCalculating time independent matrices...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:00&lt;00:00, 2991.66it/s]\nCalculating time dependent generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:00&lt;00:00, 38.70it/s]\nComputing Exponential of Generators . . . .: 1500it [00:00, 2665.82it/s]\n</pre> <pre>Started integration and Generator Calculations\nFinished integration and Generator Calculations\nComputation Time:0.1832287311553955\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nStarted interpolation\nFinished interpolation\nComputation Time:0.0007021427154541016\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nStarted Solving the differential equation\nFinished Solving the differential equation\nComputation Time:1.9782819747924805\nStarted integration and Generator Calculations\n</pre> <pre>/home/gerardo/Documents/gsuarezr/NonMarkovianMethods/nmm/redfield/redfield.py:83: RuntimeWarning: overflow encountered in exp\n  return 1 / (np.exp(w / bath.T)-1)\n</pre> <pre>Finished integration and Generator Calculations\nComputation Time:36.0932195186615\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nStarted interpolation\nFinished interpolation\nComputation Time:0.001986980438232422\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nStarted Solving the differential equation\nFinished Solving the differential equation\nComputation Time:2.01406192779541\nStarted integration and Generator Calculations\nFinished integration and Generator Calculations\nComputation Time:0.3533658981323242\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nStarted interpolation\nFinished interpolation\nComputation Time:0.001062154769897461\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nStarted Solving the differential equation\nFinished Solving the differential equation\nComputation Time:1.6531953811645508\n</pre> In\u00a0[5]: Copied! <pre>fig, ax = plt.subplots()\nax.plot(bathr.alpha * t, result.expect[0], label=\"HEOM\")\nax.plot(bathr.alpha * t, [i[0, 0] for i in result_cum],label=\"Cumulant\",linestyle=\"None\",\n        mew=2,path_effects=[pe.Stroke(linewidth=2.5, foreground='k'), pe.Normal()],zorder=4,\n        marker=\"x\")\nax.plot(bathr.alpha * t, [i[0, 0] for i in result_red],\"-.\", label=\"Redfield\")\n\nax.legend()\nax.set_xlabel(r\"$\\alpha t$\", fontsize=15)\nax.set_ylabel(r\"$\\rho_{1,1}(t)$\", fontsize=15)\nax.set_xlim(0, 5)\n\n# Add inset\ninset = fig.add_axes([0.55, 0.6, 0.15, 0.15])  # [left, bottom, width, height]\ninset.plot(bathr.alpha * t, result.expect[0])\ninset.plot(bathr.alpha * t, [i[0, 0] for i in result_cum21])\ninset.plot(bathr.alpha * t, [i[0, 0] for i in result_red])\ninset.set_xlim(55, 57)  # Specify inset xlim\ninset.set_ylim(0.16, 0.2)  # Specify inset ylim\ninset.xaxis.set_major_locator(plt.MaxNLocator(2))\ninset.yaxis.set_major_locator(plt.MaxNLocator(2))\n\nplt.show()\n\n\nfig, ax = plt.subplots()\nax.plot(bathr.alpha * t, np.abs(result.expect[1]), label=\"HEOM\")\nax.plot(bathr.alpha * t, np.abs([i[0, 1] for i in result_cum]),label=\"Cumulant\",linestyle=\"None\",\n        mew=2,path_effects=[pe.Stroke(linewidth=2.5, foreground='k'), pe.Normal()],zorder=4,\n        marker=\"x\")\nax.plot(bathr.alpha * t, np.abs([i[0, 1] for i in result_red]),\"-.\", label=\"Redfield\")\nax.legend()\nax.set_xlim(0, 5)\nax.set_xlabel(r\"$\\alpha t$\", fontsize=15)\nax.set_ylabel(r\"$| \\rho_{1,2}(t) |$\", fontsize=15)\n# Add inset\ninset = fig.add_axes([0.45, 0.75, 0.15, 0.15])  # [left, bottom, width, height]\ninset.plot(bathr.alpha * t, np.abs(result.expect[1]))\ninset.plot(bathr.alpha * t, np.abs([i[0, 1] for i in result_cum21]))\ninset.plot(bathr.alpha * t, np.abs([i[0, 1] for i in result_red]))\ninset.set_xlim(55, 57)  # Specify inset xlim\ninset.set_ylim(0.29, 0.32)  # Specify inset ylim\ninset.xaxis.set_major_locator(plt.MaxNLocator(2))\ninset.yaxis.set_major_locator(plt.MaxNLocator(2))\n\nplt.show()\n\nfid_red=[1-qt.fidelity(result.states[i],qt.Qobj(result_red2[i])) for i in range(len(t))]\nfid_cum=[1-qt.fidelity(result.states[i],qt.Qobj(result_cum[i])) for i in range(len(t))]\nfid_red_int=[1-qt.fidelity(result.states[i],qt.Qobj(result_red[i])) for i in range(len(t))]\nfid_cum_int=[1-qt.fidelity(result.states[i],qt.Qobj(result_cum21[i])) for i in range(len(t))]\ndown=6 # downsample the fidelity for better visualization\nplt.plot(bathr.alpha*t[::down],fid_cum_int[::down],\"--\",label=\"Cumulant GK\",markevery=10,zorder=4)\nplt.plot(bathr.alpha*t[::down],fid_red_int[::down],\"--\",label=\"Redfield GK\",markevery=10,zorder=4)\nplt.plot(bathr.alpha*t[::down],fid_cum[::down],label=\"Cumulant\")\nplt.plot(bathr.alpha*t[::down],fid_red[::down],label=\"Redfield\")\nplt.legend()\nax = plt.gca()\n\nax.ticklabel_format(axis='y', style='sci', scilimits=(-4, -4), useMathText=True)\n\n\nplt.xlabel(r\"$\\alpha t$\",fontsize=15)\nplt.ylabel(r\"$1-\\mathcal{F}_{HEOM}(\\rho)$\",fontsize=15)\n\nplt.show()\nmethods2=[\"Cumulant\",\"Redfield\"]\nplt.bar(methods2, np.array([end_cum2-end_cum,(end_redfield2-end_cum2)]),color=\"orange\")\nmethods2=[\"HEOM\",\"Cumulant\",\"Redfield\"]\nplt.bar(methods2, [end_heom-start,end_cum-end_heom,end_redfield-end_cum3])\nplt.yscale(\"log\")\nplt.ylabel(r\"$\\log(\\tau (s))$\",fontsize=15)\n\nplt.show()\n</pre> fig, ax = plt.subplots() ax.plot(bathr.alpha * t, result.expect[0], label=\"HEOM\") ax.plot(bathr.alpha * t, [i[0, 0] for i in result_cum],label=\"Cumulant\",linestyle=\"None\",         mew=2,path_effects=[pe.Stroke(linewidth=2.5, foreground='k'), pe.Normal()],zorder=4,         marker=\"x\") ax.plot(bathr.alpha * t, [i[0, 0] for i in result_red],\"-.\", label=\"Redfield\")  ax.legend() ax.set_xlabel(r\"$\\alpha t$\", fontsize=15) ax.set_ylabel(r\"$\\rho_{1,1}(t)$\", fontsize=15) ax.set_xlim(0, 5)  # Add inset inset = fig.add_axes([0.55, 0.6, 0.15, 0.15])  # [left, bottom, width, height] inset.plot(bathr.alpha * t, result.expect[0]) inset.plot(bathr.alpha * t, [i[0, 0] for i in result_cum21]) inset.plot(bathr.alpha * t, [i[0, 0] for i in result_red]) inset.set_xlim(55, 57)  # Specify inset xlim inset.set_ylim(0.16, 0.2)  # Specify inset ylim inset.xaxis.set_major_locator(plt.MaxNLocator(2)) inset.yaxis.set_major_locator(plt.MaxNLocator(2))  plt.show()   fig, ax = plt.subplots() ax.plot(bathr.alpha * t, np.abs(result.expect[1]), label=\"HEOM\") ax.plot(bathr.alpha * t, np.abs([i[0, 1] for i in result_cum]),label=\"Cumulant\",linestyle=\"None\",         mew=2,path_effects=[pe.Stroke(linewidth=2.5, foreground='k'), pe.Normal()],zorder=4,         marker=\"x\") ax.plot(bathr.alpha * t, np.abs([i[0, 1] for i in result_red]),\"-.\", label=\"Redfield\") ax.legend() ax.set_xlim(0, 5) ax.set_xlabel(r\"$\\alpha t$\", fontsize=15) ax.set_ylabel(r\"$| \\rho_{1,2}(t) |$\", fontsize=15) # Add inset inset = fig.add_axes([0.45, 0.75, 0.15, 0.15])  # [left, bottom, width, height] inset.plot(bathr.alpha * t, np.abs(result.expect[1])) inset.plot(bathr.alpha * t, np.abs([i[0, 1] for i in result_cum21])) inset.plot(bathr.alpha * t, np.abs([i[0, 1] for i in result_red])) inset.set_xlim(55, 57)  # Specify inset xlim inset.set_ylim(0.29, 0.32)  # Specify inset ylim inset.xaxis.set_major_locator(plt.MaxNLocator(2)) inset.yaxis.set_major_locator(plt.MaxNLocator(2))  plt.show()  fid_red=[1-qt.fidelity(result.states[i],qt.Qobj(result_red2[i])) for i in range(len(t))] fid_cum=[1-qt.fidelity(result.states[i],qt.Qobj(result_cum[i])) for i in range(len(t))] fid_red_int=[1-qt.fidelity(result.states[i],qt.Qobj(result_red[i])) for i in range(len(t))] fid_cum_int=[1-qt.fidelity(result.states[i],qt.Qobj(result_cum21[i])) for i in range(len(t))] down=6 # downsample the fidelity for better visualization plt.plot(bathr.alpha*t[::down],fid_cum_int[::down],\"--\",label=\"Cumulant GK\",markevery=10,zorder=4) plt.plot(bathr.alpha*t[::down],fid_red_int[::down],\"--\",label=\"Redfield GK\",markevery=10,zorder=4) plt.plot(bathr.alpha*t[::down],fid_cum[::down],label=\"Cumulant\") plt.plot(bathr.alpha*t[::down],fid_red[::down],label=\"Redfield\") plt.legend() ax = plt.gca()  ax.ticklabel_format(axis='y', style='sci', scilimits=(-4, -4), useMathText=True)   plt.xlabel(r\"$\\alpha t$\",fontsize=15) plt.ylabel(r\"$1-\\mathcal{F}_{HEOM}(\\rho)$\",fontsize=15)  plt.show() methods2=[\"Cumulant\",\"Redfield\"] plt.bar(methods2, np.array([end_cum2-end_cum,(end_redfield2-end_cum2)]),color=\"orange\") methods2=[\"HEOM\",\"Cumulant\",\"Redfield\"] plt.bar(methods2, [end_heom-start,end_cum-end_heom,end_redfield-end_cum3]) plt.yscale(\"log\") plt.ylabel(r\"$\\log(\\tau (s))$\",fontsize=15)  plt.show() <pre>/home/gerardo/.pyenv/versions/3.13.0/envs/qutip-dev/lib/python3.13/site-packages/matplotlib/cbook.py:1709: ComplexWarning: Casting complex values to real discards the imaginary part\n  return math.isfinite(val)\n/home/gerardo/.pyenv/versions/3.13.0/envs/qutip-dev/lib/python3.13/site-packages/matplotlib/cbook.py:1345: ComplexWarning: Casting complex values to real discards the imaginary part\n  return np.asarray(x, float)\n</pre>"},{"location":"Qubit_example/#example-2-the-refined-weak-coupling-cumulant-equation-for-a-spin-boson-model-with-an-sub-ohmic-spectral-density","title":"Example 2: The Refined Weak Coupling/ Cumulant equation for a spin boson model with an sub-Ohmic spectral density\u00b6","text":"<p>This example provides the necessary code to reproduce the calculations from 2, where the Hamiltonian of the spin-boson model is given by</p> <p>\\begin{equation}      H = \\underbrace{\\frac{\\omega_{0}}{2} \\sigma{z} + \\frac{\\Delta}{2} \\sigma{x} + \\frac{\\delta}{2} \\sigma{y} }_{H_S} + \\underbrace{\\sum_{k} w_{k} a_{k}^{\\dagger} a_{k}}_{H_B} + \\underbrace{\\sum_{k} g_k \\sigma{z} (a_{k}+a_{k}^{\\dagger})}_{H_I}. \\end{equation}</p> <p>The spectral density is given by</p> <p>\\begin{align}     J(\\omega) = \\alpha\\frac{\\omega^s}{\\omega_c^{s-1}} e^{-\\omega / \\omega_c} , \\end{align}</p> <p>We first begin by importing the necessary packages</p>"},{"location":"api/","title":"API reference","text":""},{"location":"api/#nmm.utils.BosonicBath","title":"<code>BosonicBath</code>","text":"Source code in <code>nmm/utils/baths.py</code> <pre><code>class BosonicBath:\n    def __init__(self, T):\n        self.T = T\n\n    def bose(self, \u03bd):\n        r\"\"\"\n        It computes the Bose-Einstein distribution\n\n        $$ n(\\omega)=\\frac{1}{e^{\\beta \\omega}-1} $$\n\n        Parameters:\n        ----------\n        \u03bd: float\n            The mode at which to compute the thermal population\n\n        Returns:\n        -------\n        float\n            The thermal population of mode \u03bd\n        \"\"\"\n        if self.T == 0:\n            return 0\n        if np.isclose(\u03bd, 0).all():\n            return 0\n        return np.exp(-\u03bd / self.T) / (1-np.exp(-\u03bd / self.T))\n\n    def spectral_density(self, w):\n        return None\n\n    def correlation_function(self, t):\n        return None\n\n    def power_spectrum(self, w):\n        return 2*(self.bose(w)+1)*self.spectral_density(w)\n</code></pre>"},{"location":"api/#nmm.utils.BosonicBath.bose","title":"<code>bose(\u03bd)</code>","text":"<p>It computes the Bose-Einstein distribution</p> \\[ n(\\omega)=\\frac{1}{e^{\\beta \\omega}-1} \\] Parameters: <p>\u03bd: float     The mode at which to compute the thermal population</p> Returns: <p>float     The thermal population of mode \u03bd</p> Source code in <code>nmm/utils/baths.py</code> <pre><code>def bose(self, \u03bd):\n    r\"\"\"\n    It computes the Bose-Einstein distribution\n\n    $$ n(\\omega)=\\frac{1}{e^{\\beta \\omega}-1} $$\n\n    Parameters:\n    ----------\n    \u03bd: float\n        The mode at which to compute the thermal population\n\n    Returns:\n    -------\n    float\n        The thermal population of mode \u03bd\n    \"\"\"\n    if self.T == 0:\n        return 0\n    if np.isclose(\u03bd, 0).all():\n        return 0\n    return np.exp(-\u03bd / self.T) / (1-np.exp(-\u03bd / self.T))\n</code></pre>"},{"location":"api/#nmm.utils.OhmicBath","title":"<code>OhmicBath</code>","text":"<p>               Bases: <code>BosonicBath</code></p> Source code in <code>nmm/utils/baths.py</code> <pre><code>class OhmicBath(BosonicBath):\n    def __init__(self, T, coupling, cutoff):\n        super().__init__(T)\n        self.coupling = coupling\n        self.cutoff = cutoff\n        self.label = \"ohmic\"\n\n    def spectral_density(self, w):\n        r\"\"\"\n        It describes the spectral density of an Ohmic spectral density given by\n\n        $$ J(\\omega)= \\alpha \\omega e^{-\\frac{|\\omega|}{\\omega_{c}}} $$\n\n        Parameters\n        ----------\n        \"\"\"\n        return self.coupling*w*np.exp(-abs(w)/self.cutoff)\n\n    def correlation_function(self, t):\n        return None\n</code></pre>"},{"location":"api/#nmm.utils.OhmicBath.spectral_density","title":"<code>spectral_density(w)</code>","text":"<p>It describes the spectral density of an Ohmic spectral density given by</p> \\[ J(\\omega)= \\alpha \\omega e^{-\\frac{|\\omega|}{\\omega_{c}}} \\] Source code in <code>nmm/utils/baths.py</code> <pre><code>def spectral_density(self, w):\n    r\"\"\"\n    It describes the spectral density of an Ohmic spectral density given by\n\n    $$ J(\\omega)= \\alpha \\omega e^{-\\frac{|\\omega|}{\\omega_{c}}} $$\n\n    Parameters\n    ----------\n    \"\"\"\n    return self.coupling*w*np.exp(-abs(w)/self.cutoff)\n</code></pre>"},{"location":"api/#nmm.utils.baths","title":"<code>baths</code>","text":""},{"location":"api/#nmm.utils.baths.BosonicBath","title":"<code>BosonicBath</code>","text":"Source code in <code>nmm/utils/baths.py</code> <pre><code>class BosonicBath:\n    def __init__(self, T):\n        self.T = T\n\n    def bose(self, \u03bd):\n        r\"\"\"\n        It computes the Bose-Einstein distribution\n\n        $$ n(\\omega)=\\frac{1}{e^{\\beta \\omega}-1} $$\n\n        Parameters:\n        ----------\n        \u03bd: float\n            The mode at which to compute the thermal population\n\n        Returns:\n        -------\n        float\n            The thermal population of mode \u03bd\n        \"\"\"\n        if self.T == 0:\n            return 0\n        if np.isclose(\u03bd, 0).all():\n            return 0\n        return np.exp(-\u03bd / self.T) / (1-np.exp(-\u03bd / self.T))\n\n    def spectral_density(self, w):\n        return None\n\n    def correlation_function(self, t):\n        return None\n\n    def power_spectrum(self, w):\n        return 2*(self.bose(w)+1)*self.spectral_density(w)\n</code></pre>"},{"location":"api/#nmm.utils.baths.BosonicBath.bose","title":"<code>bose(\u03bd)</code>","text":"<p>It computes the Bose-Einstein distribution</p> \\[ n(\\omega)=\\frac{1}{e^{\\beta \\omega}-1} \\] Parameters: <p>\u03bd: float     The mode at which to compute the thermal population</p> Returns: <p>float     The thermal population of mode \u03bd</p> Source code in <code>nmm/utils/baths.py</code> <pre><code>def bose(self, \u03bd):\n    r\"\"\"\n    It computes the Bose-Einstein distribution\n\n    $$ n(\\omega)=\\frac{1}{e^{\\beta \\omega}-1} $$\n\n    Parameters:\n    ----------\n    \u03bd: float\n        The mode at which to compute the thermal population\n\n    Returns:\n    -------\n    float\n        The thermal population of mode \u03bd\n    \"\"\"\n    if self.T == 0:\n        return 0\n    if np.isclose(\u03bd, 0).all():\n        return 0\n    return np.exp(-\u03bd / self.T) / (1-np.exp(-\u03bd / self.T))\n</code></pre>"},{"location":"api/#nmm.utils.baths.OhmicBath","title":"<code>OhmicBath</code>","text":"<p>               Bases: <code>BosonicBath</code></p> Source code in <code>nmm/utils/baths.py</code> <pre><code>class OhmicBath(BosonicBath):\n    def __init__(self, T, coupling, cutoff):\n        super().__init__(T)\n        self.coupling = coupling\n        self.cutoff = cutoff\n        self.label = \"ohmic\"\n\n    def spectral_density(self, w):\n        r\"\"\"\n        It describes the spectral density of an Ohmic spectral density given by\n\n        $$ J(\\omega)= \\alpha \\omega e^{-\\frac{|\\omega|}{\\omega_{c}}} $$\n\n        Parameters\n        ----------\n        \"\"\"\n        return self.coupling*w*np.exp(-abs(w)/self.cutoff)\n\n    def correlation_function(self, t):\n        return None\n</code></pre>"},{"location":"api/#nmm.utils.baths.OhmicBath.spectral_density","title":"<code>spectral_density(w)</code>","text":"<p>It describes the spectral density of an Ohmic spectral density given by</p> \\[ J(\\omega)= \\alpha \\omega e^{-\\frac{|\\omega|}{\\omega_{c}}} \\] Source code in <code>nmm/utils/baths.py</code> <pre><code>def spectral_density(self, w):\n    r\"\"\"\n    It describes the spectral density of an Ohmic spectral density given by\n\n    $$ J(\\omega)= \\alpha \\omega e^{-\\frac{|\\omega|}{\\omega_{c}}} $$\n\n    Parameters\n    ----------\n    \"\"\"\n    return self.coupling*w*np.exp(-abs(w)/self.cutoff)\n</code></pre>"},{"location":"api/#nmm.cumulant.cumulant","title":"<code>cumulant</code>","text":""},{"location":"api/#nmm.cumulant.cumulant.csolve","title":"<code>csolve</code>","text":"Source code in <code>nmm/cumulant/cumulant.py</code> <pre><code>class csolve:\n    def __init__(self, Hsys, t, baths, Qs, eps=1e-4, cython=False, limit=50,\n                 matsubara=True,ls=False):\n        self.Hsys = Hsys\n        self.t = t\n        self.eps = eps\n        self.limit = limit\n        self.dtype = Hsys.dtype\n        self.ls=ls\n\n        if isinstance(Hsys, qutip_Qobj):\n            self._qutip = True\n        else:\n            self._qutip = False\n        if cython:\n            self.baths = [bath_csolve(b.T, eps, b.coupling, b.cutoff, b.label)\n                          for b in baths]\n        else:\n            self.baths = baths\n        self.Qs = Qs\n        self.cython = cython\n        self.matsubara = matsubara\n\n    def _tree_flatten(self):\n        children = (self.Hsys, self.t, self.eps,\n                    self.limit, self.baths, self.dtype)\n        aux_data = {}\n        return (children, aux_data)\n\n    @classmethod\n    def _tree_unflatten(cls, aux_data, children):\n        return cls(*children, **aux_data)\n    def bose(self,w,bath):\n        r\"\"\"\n        It computes the Bose-Einstein distribution\n\n        $$ n(\\omega)=\\frac{1}{e^{\\beta \\omega}-1} $$\n\n        Parameters:\n        ----------\n        nu: float\n            The mode at which to compute the thermal population\n\n        Returns:\n        -------\n        float\n            The thermal population of mode nu\n        \"\"\"\n        if bath.T == 0:\n            return 0\n        if np.isclose(w, 0).all():\n            return 0\n        return np.exp(-w / bath.T) / (1-np.exp(-w / bath.T))\n\n    def gamma_fa(self, bath, w, w1, t):\n        r\"\"\"\n        It describes the decay rates for the Filtered Approximation of the\n        cumulant equation\n\n        $$\\gamma(\\omega,\\omega^\\prime,t)= 2\\pi t e^{i \\frac{\\omega^\\prime\n        -\\omega}{2}t}\\mathrm{sinc} \\left(\\frac{\\omega^\\prime-\\omega}{2}t\\right)\n         \\left(J(\\omega^\\prime) (n(\\omega^\\prime)+1)J(\\omega) (n(\\omega)+1)\n         \\right)^{\\frac{1}{2}}$$\n\n        Parameters\n        ----------\n\n        w : float or numpy.ndarray\n\n        w1 : float or numpy.ndarray\n\n        t : float or numpy.ndarray\n\n        Returns\n        -------\n        float or numpy.ndarray\n            It returns a value or array describing the decay between the levels\n            with energies w and w1 at time t\n\n        \"\"\"\n        var = (2 * t * np.exp(1j * (w1 - w) * t / 2)\n               * np.sinc((w1 - w) * t / (2 * np.pi))\n               * np.sqrt(bath.spectral_density(w1) * (self.bose(w1,bath) + 1))\n               * np.sqrt(bath.spectral_density(w) * (self.bose(w,bath) + 1)))\n        return var\n\n    def _gamma_(self, nu, bath, w, w1, t):\n        r\"\"\"\n        It describes the Integrand of the decay rates of the cumulant equation\n        for bosonic baths\n\n        $$\\Gamma(w,w',t)=\\int_{0}^{t} dt_1 \\int_{0}^{t} dt_2\n        e^{i (w t_1 - w' t_2)} \\mathcal{C}(t_{1},t_{2})$$\n\n        Parameters:\n        ----------\n\n        w: float or numpy.ndarray\n\n        w1: float or numpy.ndarray\n\n        t: float or numpy.ndarray\n\n        Returns:\n        --------\n        float or numpy.ndarray\n            It returns a value or array describing the decay between the levels\n            with energies w and w1 at time t\n\n        \"\"\"\n\n        self._mul = 1/np.pi\n        var = (\n            np.exp(1j * (w - w1) / 2 * t)\n            * bath.spectral_density(nu)\n            * (np.sinc((w - nu) / (2 * np.pi) * t)\n               * np.sinc((w1 - nu) / (2 * np.pi) * t))\n            * (self.bose(nu,bath) + 1)\n        )\n        var += (\n            np.exp(1j * (w - w1) / 2 * t)\n            * bath.spectral_density(nu)\n            * (np.sinc((w + nu) / (2 * np.pi) * t)\n               * np.sinc((w1 + nu) / (2 * np.pi) * t))\n            * self.bose(nu,bath)\n        )\n\n        var = var*self._mul\n\n        return var\n\n    def gamma_gen(self, bath, w, w1, t, approximated=False):\n        r\"\"\"\n        It describes the the decay rates of the cumulant equation\n        for bosonic baths\n\n        $$\\Gamma(\\omega,\\omega',t) = t^{2}\\int_{0}^{\\infty} d\\omega \n        e^{i\\frac{\\omega-\\omega'}{2} t} J(\\omega) \\left[ (n(\\omega)+1) \n        sinc\\left(\\frac{(\\omega-\\omega)t}{2}\\right)\n        sinc\\left(\\frac{(\\omega'-\\omega)t}{2}\\right)+ n(\\omega) \n        sinc\\left(\\frac{(\\omega+\\omega)t}{2}\\right) \n        sinc\\left(\\frac{(\\omega'+\\omega)t}{2}\\right)   \\right]$$\n\n        Parameters\n        ----------\n\n        w : float or numpy.ndarray\n        w1 : float or numpy.ndarray\n        t : float or numpy.ndarray\n\n        Returns\n        -------\n        float or numpy.ndarray\n            It returns a value or array describing the decay between the levels\n            with energies w and w1 at time t\n\n        \"\"\"\n        if isinstance(t, type(jnp.array([2]))):\n            t = np.array(t.tolist())\n        if isinstance(t, list):\n            t = np.array(t)\n        if approximated:\n            return self.gamma_fa(bath, w, w1, t)\n        if self.matsubara:\n            if w == w1:\n                return self.decayww(bath, w, t)\n            else:\n                return self.decayww2(bath, w, w1, t)\n        if self.cython:\n            return bath.gamma(np.real(w), np.real(w1), t, limit=self.limit)\n\n        else:\n            integrals = quad_vec(\n                self._gamma_,\n                0,\n                np.inf,\n                args=(bath, w, w1, t),\n                epsabs=self.eps,\n                epsrel=self.eps,\n                quadrature=\"gk21\"\n            )[0]\n            return t*t*integrals\n\n    def sparsify(self, vectors, tol=10):\n        dims = vectors[0].dims\n        new = []\n        for vector in vectors:\n            top = np.max(np.abs(vector.full()))\n            vector = (vector/top).full().round(tol)*top\n            vector = qutip_Qobj(vector).to(\"CSR\")\n            vector.dims = dims\n\n            new.append(vector)\n        return new\n\n    def jump_operators(self, Q):\n        evals, all_state = self.Hsys.eigenstates()\n        N = len(all_state)\n        collapse_list = []\n        ws = []\n        for j in range(N):\n            for k in range(j + 1, N):\n                Deltajk = evals[k] - evals[j]\n                ws.append(Deltajk)\n                collapse_list.append(\n                    (\n                        all_state[j]\n                        * all_state[j].dag()\n                        * Q\n                        * all_state[k]\n                        * all_state[k].dag()\n                    )\n                )  # emission\n                ws.append(-Deltajk)\n                collapse_list.append(\n                    (\n                        all_state[k]\n                        * all_state[k].dag()\n                        * Q\n                        * all_state[j]\n                        * all_state[j].dag()\n                    )\n                )  # absorption\n        collapse_list.append(Q - sum(collapse_list))  # Dephasing\n        ws.append(0)\n        output = defaultdict(list)\n        for k, key in enumerate(ws):\n            output[jnp.round(key, 12).item()].append(collapse_list[k])\n        eldict = {x: sum(y) for x, y in output.items()}\n        dictrem = {}\n        empty = 0*self.Hsys\n        for keys, values in eldict.items():\n            if not (values == empty):\n                if isinstance(values,qutip_Qobj):\n                    dictrem[keys] = values.to(\"CSR\")\n                else:\n                    dictrem[keys] = values\n        return dictrem\n\n    def decays(self, combinations, bath, approximated):\n        rates = {}\n        done = []\n        for i in tqdm(combinations, desc='Calculating Integrals ...',\n                      dynamic_ncols=True):\n            done.append(i)\n            j = (i[1], i[0])\n            if (j in done) &amp; (i != j):\n                rates[i] = np.conjugate(rates[j])\n            else:\n                rates[i] = self.gamma_gen(bath, i[0], i[1], self.t,\n                                          approximated)\n        return rates\n\n    def matrix_form(self, jumps, combinations):\n        matrixform = {}\n        lsform={}\n        for i in tqdm(\n                combinations, desc='Calculating time independent matrices...',\n                dynamic_ncols=True):\n            ada=jumps[i[0]].dag() * jumps[i[1]]\n            matrixform[i] = (\n                spre(jumps[i[1]]) * spost(jumps[i[0]].dag()) - 1 *\n                (0.5 *\n                 (spre(ada) +spost(ada))))\n            lsform[i]= -1j*(spre(ada)-spost(ada))\n\n        return matrixform,lsform\n\n    def generator(self, approximated=False):\n        generators = []\n        for Q, bath in zip(self.Qs, self.baths):\n            jumps = self.jump_operators(Q)\n            ws = list(jumps.keys())\n            combinations = list(itertools.product(ws, ws))\n            rates = self.decays(combinations, bath, approximated)\n            matrices,lsform = self.matrix_form(jumps, combinations)\n            if self.ls is False:\n                superop = sum(\n                    (rates[i] * np.array(matrices[i])\n                    for i in tqdm(\n                        combinations,\n                        desc=\"Calculating time dependent generators\")))\n            else:\n                LS= self.LS(combinations,bath,self.t)            \n                superop = sum(\n                    (LS[i]*np.array(lsform[i])+rates[i] * np.array(matrices[i])\n                    for i in tqdm(\n                        combinations,\n                        desc=\"Calculating time dependent generators\")))\n            generators.extend(superop)\n            del superop\n        self.generators = self._reformat(generators)\n\n    def _reformat(self, generators):\n        if len(generators) == len(self.t):\n            return generators\n        else:\n            one_list_for_each_bath = [\n                generators\n                [i * len(self.t): (i + 1) * len(self.t)]\n                for i in range(\n                    0, int(\n                        len(generators) / len(self.t)))]\n            composed = list(map(sum, zip(*one_list_for_each_bath)))\n            return composed\n\n    def evolution(self, rho0, approximated=False):\n        r\"\"\"\n        This function computes the evolution of the state $\\rho(0)$\n\n        Parameters\n        ----------\n\n        rho0 : numpy.ndarray or qutip.Qobj\n            The initial state of the quantum system under consideration.\n\n        approximated : bool\n            When False the full cumulant equation/refined weak coupling is\n            computed, when True the Filtered Approximation (FA is computed),\n            this greatly reduces computational time, at the expense of\n            diminishing accuracy particularly for the populations of the system\n            at early times.\n\n        Returns\n        -------\n        list\n            a list containing all of the density matrices, at all timesteps of\n            the evolution\n        \"\"\"\n        self.generator(approximated)\n        states = [\n            (i).expm()(rho0)\n            for k,i in tqdm(\n                enumerate(self.generators),\n                desc='Computing Exponential of Generators . . . .')]  # this counts time incorrectly\n        return states\n    def _decayww(self,bath, w, t):\n        cks=np.array([i.coefficient for i in bath.exponents])\n        vks=np.array([i.exponent for i in bath.exponents])\n        result=[]\n        for i in range(len(cks)):\n            term1 =(vks[i]*t-1j*w*t-1)+np.exp(-(vks[i]-1j*w)*t)\n            term1=term1*cks[i]/(vks[i]-1j*w)**2\n            result.append(term1)\n        return 2*np.real(sum(result))\n\n    def _decayww2(self,bath ,w, w1, t):\n        cks=np.array([i.coefficient for i in bath.exponents])\n        vks=np.array([i.exponent for i in bath.exponents])\n        result=[]\n        for i in range(len(cks)):\n            a=(vks[i]-1j*w1)\n            b=(vks[i]-1j*w)\n            term1=cks[i]*np.exp(-b*t)/(a*b)\n            term2=np.conjugate(cks[i])*np.exp(-np.conjugate(a)*t)/(np.conjugate(a)*np.conjugate(b))\n            term3=cks[i]*((1/b)-(np.exp(1j*(w-w1)*t)/a))\n            term4=np.conjugate(cks[i])*((1/np.conjugate(a))-(np.exp(1j*(w-w1)*t)/np.conjugate(b)))\n            actual=term1+term2+(1j*(term3+term4)/(w-w1))\n            result.append(actual)\n        return sum(result)\n\n\n    def decayww2(self, bath, w, w1, t):\n        t_array = np.asarray(t)\n        result = self._decayww2(bath, w,w1, t_array)\n        zero_indices = np.where(t_array == 0)\n        result[zero_indices] = 0\n        return result\n\n    def decayww(self, bath, w, t):\n        t_array = np.asarray(t)\n        result = self._decayww(bath, w, t_array)\n        zero_indices = np.where(t_array == 0)\n        result[zero_indices] = 0\n        return result\n\n    def _LS(self, bath, w,w1, t):\n        if w!=w1:\n            cks=np.array([i.coefficient for i in bath.exponents])\n            vks=np.array([i.exponent for i in bath.exponents])\n            mask = np.imag(cks) &gt;= 0\n            cks=cks[mask]\n            vks=vks[mask]\n            result=[]\n            for i in range(len(cks)):\n                a=(vks[i]-1j*w1)\n                b=(vks[i]-1j*w)\n                term1=cks[i]*np.exp(-b*t)/(a*b)\n                term2=np.conjugate(cks[i])*np.exp(-np.conjugate(a)*t)/(np.conjugate(a)*np.conjugate(b))\n                term3=cks[i]*((1/b)-(np.exp(1j*(w-w1)*t)/a))\n                term4=np.conjugate(cks[i])*((1/np.conjugate(a))-(np.exp(1j*(w-w1)*t)/np.conjugate(b)))\n                actual=term1-term2+(1j*(term3-term4)/(w-w1))\n                result.append(actual)\n            return sum(result)/2j\n        else:\n            cks=np.array([i.coefficient for i in bath.exponents])\n            vks=np.array([i.exponent for i in bath.exponents])\n            result=[]\n            for i in range(len(cks)):\n                term1 =(vks[i]*t-1j*w*t-1)+np.exp(-(vks[i]-1j*w)*t)\n                term1=term1*cks[i]/(vks[i]-1j*w)**2\n                result.append(term1)\n            return np.imag(sum(result))/2\n    def LS(self, combinations, bath, t):\n        rates = {}\n        done = []\n        for i in combinations:\n            done.append(i)\n            j = (i[1], i[0])\n            if (j in done) &amp; (i != j):\n                rates[i] = np.conjugate(rates[j])\n            else:\n                rates[i] = self._LS(bath, i[0], i[1], t)\n        return rates\n</code></pre>"},{"location":"api/#nmm.cumulant.cumulant.csolve.bose","title":"<code>bose(w, bath)</code>","text":"<p>It computes the Bose-Einstein distribution</p> \\[ n(\\omega)=\\frac{1}{e^{\\beta \\omega}-1} \\] Parameters: <p>nu: float     The mode at which to compute the thermal population</p> Returns: <p>float     The thermal population of mode nu</p> Source code in <code>nmm/cumulant/cumulant.py</code> <pre><code>def bose(self,w,bath):\n    r\"\"\"\n    It computes the Bose-Einstein distribution\n\n    $$ n(\\omega)=\\frac{1}{e^{\\beta \\omega}-1} $$\n\n    Parameters:\n    ----------\n    nu: float\n        The mode at which to compute the thermal population\n\n    Returns:\n    -------\n    float\n        The thermal population of mode nu\n    \"\"\"\n    if bath.T == 0:\n        return 0\n    if np.isclose(w, 0).all():\n        return 0\n    return np.exp(-w / bath.T) / (1-np.exp(-w / bath.T))\n</code></pre>"},{"location":"api/#nmm.cumulant.cumulant.csolve.evolution","title":"<code>evolution(rho0, approximated=False)</code>","text":"<p>This function computes the evolution of the state \\(\\rho(0)\\)</p> <p>Parameters:</p> Name Type Description Default <code>rho0</code> <code>ndarray or Qobj</code> <p>The initial state of the quantum system under consideration.</p> required <code>approximated</code> <code>bool</code> <p>When False the full cumulant equation/refined weak coupling is computed, when True the Filtered Approximation (FA is computed), this greatly reduces computational time, at the expense of diminishing accuracy particularly for the populations of the system at early times.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>a list containing all of the density matrices, at all timesteps of the evolution</p> Source code in <code>nmm/cumulant/cumulant.py</code> <pre><code>def evolution(self, rho0, approximated=False):\n    r\"\"\"\n    This function computes the evolution of the state $\\rho(0)$\n\n    Parameters\n    ----------\n\n    rho0 : numpy.ndarray or qutip.Qobj\n        The initial state of the quantum system under consideration.\n\n    approximated : bool\n        When False the full cumulant equation/refined weak coupling is\n        computed, when True the Filtered Approximation (FA is computed),\n        this greatly reduces computational time, at the expense of\n        diminishing accuracy particularly for the populations of the system\n        at early times.\n\n    Returns\n    -------\n    list\n        a list containing all of the density matrices, at all timesteps of\n        the evolution\n    \"\"\"\n    self.generator(approximated)\n    states = [\n        (i).expm()(rho0)\n        for k,i in tqdm(\n            enumerate(self.generators),\n            desc='Computing Exponential of Generators . . . .')]  # this counts time incorrectly\n    return states\n</code></pre>"},{"location":"api/#nmm.cumulant.cumulant.csolve.gamma_fa","title":"<code>gamma_fa(bath, w, w1, t)</code>","text":"<p>It describes the decay rates for the Filtered Approximation of the cumulant equation</p> \\[\\gamma(\\omega,\\omega^\\prime,t)= 2\\pi t e^{i \\frac{\\omega^\\prime -\\omega}{2}t}\\mathrm{sinc} \\left(\\frac{\\omega^\\prime-\\omega}{2}t\\right)  \\left(J(\\omega^\\prime) (n(\\omega^\\prime)+1)J(\\omega) (n(\\omega)+1)  \\right)^{\\frac{1}{2}}\\] <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float or ndarray</code> required <code>w1</code> <code>float or ndarray</code> required <code>t</code> <code>float or ndarray</code> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>It returns a value or array describing the decay between the levels with energies w and w1 at time t</p> Source code in <code>nmm/cumulant/cumulant.py</code> <pre><code>def gamma_fa(self, bath, w, w1, t):\n    r\"\"\"\n    It describes the decay rates for the Filtered Approximation of the\n    cumulant equation\n\n    $$\\gamma(\\omega,\\omega^\\prime,t)= 2\\pi t e^{i \\frac{\\omega^\\prime\n    -\\omega}{2}t}\\mathrm{sinc} \\left(\\frac{\\omega^\\prime-\\omega}{2}t\\right)\n     \\left(J(\\omega^\\prime) (n(\\omega^\\prime)+1)J(\\omega) (n(\\omega)+1)\n     \\right)^{\\frac{1}{2}}$$\n\n    Parameters\n    ----------\n\n    w : float or numpy.ndarray\n\n    w1 : float or numpy.ndarray\n\n    t : float or numpy.ndarray\n\n    Returns\n    -------\n    float or numpy.ndarray\n        It returns a value or array describing the decay between the levels\n        with energies w and w1 at time t\n\n    \"\"\"\n    var = (2 * t * np.exp(1j * (w1 - w) * t / 2)\n           * np.sinc((w1 - w) * t / (2 * np.pi))\n           * np.sqrt(bath.spectral_density(w1) * (self.bose(w1,bath) + 1))\n           * np.sqrt(bath.spectral_density(w) * (self.bose(w,bath) + 1)))\n    return var\n</code></pre>"},{"location":"api/#nmm.cumulant.cumulant.csolve.gamma_gen","title":"<code>gamma_gen(bath, w, w1, t, approximated=False)</code>","text":"<p>It describes the the decay rates of the cumulant equation for bosonic baths</p> \\[\\Gamma(\\omega,\\omega',t) = t^{2}\\int_{0}^{\\infty} d\\omega  e^{i\\frac{\\omega-\\omega'}{2} t} J(\\omega) \\left[ (n(\\omega)+1)  sinc\\left(\\frac{(\\omega-\\omega)t}{2}\\right) sinc\\left(\\frac{(\\omega'-\\omega)t}{2}\\right)+ n(\\omega)  sinc\\left(\\frac{(\\omega+\\omega)t}{2}\\right)  sinc\\left(\\frac{(\\omega'+\\omega)t}{2}\\right)   \\right]\\] <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float or ndarray</code> required <code>w1</code> <code>float or ndarray</code> required <code>t</code> <code>float or ndarray</code> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>It returns a value or array describing the decay between the levels with energies w and w1 at time t</p> Source code in <code>nmm/cumulant/cumulant.py</code> <pre><code>def gamma_gen(self, bath, w, w1, t, approximated=False):\n    r\"\"\"\n    It describes the the decay rates of the cumulant equation\n    for bosonic baths\n\n    $$\\Gamma(\\omega,\\omega',t) = t^{2}\\int_{0}^{\\infty} d\\omega \n    e^{i\\frac{\\omega-\\omega'}{2} t} J(\\omega) \\left[ (n(\\omega)+1) \n    sinc\\left(\\frac{(\\omega-\\omega)t}{2}\\right)\n    sinc\\left(\\frac{(\\omega'-\\omega)t}{2}\\right)+ n(\\omega) \n    sinc\\left(\\frac{(\\omega+\\omega)t}{2}\\right) \n    sinc\\left(\\frac{(\\omega'+\\omega)t}{2}\\right)   \\right]$$\n\n    Parameters\n    ----------\n\n    w : float or numpy.ndarray\n    w1 : float or numpy.ndarray\n    t : float or numpy.ndarray\n\n    Returns\n    -------\n    float or numpy.ndarray\n        It returns a value or array describing the decay between the levels\n        with energies w and w1 at time t\n\n    \"\"\"\n    if isinstance(t, type(jnp.array([2]))):\n        t = np.array(t.tolist())\n    if isinstance(t, list):\n        t = np.array(t)\n    if approximated:\n        return self.gamma_fa(bath, w, w1, t)\n    if self.matsubara:\n        if w == w1:\n            return self.decayww(bath, w, t)\n        else:\n            return self.decayww2(bath, w, w1, t)\n    if self.cython:\n        return bath.gamma(np.real(w), np.real(w1), t, limit=self.limit)\n\n    else:\n        integrals = quad_vec(\n            self._gamma_,\n            0,\n            np.inf,\n            args=(bath, w, w1, t),\n            epsabs=self.eps,\n            epsrel=self.eps,\n            quadrature=\"gk21\"\n        )[0]\n        return t*t*integrals\n</code></pre>"},{"location":"damped_jc/","title":"Example 5: Structured environments and TCL","text":"In\u00a0[37]: Copied! <pre>import numpy as np\nfrom scipy.integrate import solve_ivp\nfrom qutip import BosonicEnvironment\nimport matplotlib.pyplot as plt\nfrom qutip import spre,spost,sprepost,sigmap,sigmam,Qobj\nfrom spectral_density_data import spectral_density\nfrom nmm import cumulant,redfield\nimport time\nfrom qutip import heom\n</pre> import numpy as np from scipy.integrate import solve_ivp from qutip import BosonicEnvironment import matplotlib.pyplot as plt from qutip import spre,spost,sprepost,sigmap,sigmam,Qobj from spectral_density_data import spectral_density from nmm import cumulant,redfield import time from qutip import heom <p>The next block of code generates and solves the system of ODEs that replaces the Volterra equation, it also provides the generator of TCL as explained in 2</p> In\u00a0[6]: Copied! <pre>def solve_c1_system(cks, vks, c1_0, t_span=(0, 50), t_eval=None):\n    \"\"\"\n    Solves the system:\n        dot{c1} = -sum yk\n        dot{yk} = -vk * yk + ck * c1\n    Parameters:\n        cks : list or array of c_k coefficients\n        vks : list or array of v_k (decay rates)\n        c1_0 : float, initial condition for c1(t)\n        t_span : tuple, (t0, tf)\n        t_eval : array, optional time grid for evaluation\n    Returns:\n        t, c1, ys : time array, c1(t) array, y_k(t) array\n    \"\"\"\n    cks = np.array(cks, dtype=complex)\n    vks = np.array(vks, dtype=complex)\n    N = len(cks)\n\n    def system(t, u):\n        c1 = u[0]\n        ys = u[1:]\n        \n        # Calculate the time derivatives of c1 and yk\n        dc1_dt = -np.sum(ys)\n        dys_dt = -(vks) * ys + cks * c1\n        \n        # Ensure ys don't go below 0 (clipping to prevent negative values)        \n        return np.concatenate([[dc1_dt], dys_dt])\n\n    # Initial conditions\n    u0 = np.concatenate([[c1_0],  np.zeros_like(cks)])\n\n    # Time grid\n    if t_eval is None:\n        t_eval = np.linspace(t_span[0], t_span[1], 1000)\n\n    # Solve ODE system using 'RK45' method for better stability\n    sol = solve_ivp(system, t_span, u0, t_eval=t_eval, method='RK45', vectorized=False)\n\n    t = sol.t\n    c1 = sol.y[0]\n    ys = sol.y[1:]\n    return t, c1, ys\ndef g4(ck,vk,w0,t):\n    # if this does not work -iwo to vk\n    diff=[]\n    sam=[]\n    for i in range(len(ck)):\n        for j in range(len(ck)):\n            if i!=j:\n                a=1j*w0-vk[i]\n                b=vk[j]-1j*w0\n                mul=(ck[i]*ck[j])/(a*b)\n                uno=np.exp(-t*b)/(vk[i]-vk[j])\n                dos=np.exp(-t*(vk[i]+vk[j]-2*1j*w0))/b\n                tres=-1/a\n                cuatro=(t - 1/a - 1/b + 1/(vk[j]-vk[i]))*np.exp(t*a)\n                diff.append(mul*(uno+dos+tres+cuatro))\n            else:\n                a=vk[i]-1j*w0\n                mul=(ck[i]**2)/(a**3) \n                uno=1-np.exp(-2*t*a)-2*t*np.exp(-t*a)*a\n                sam.append(mul*uno)\n    different= sum(diff)\n    same=sum(sam)\n    return 2*(different+same)\ndef g2(ck,vk,w0,t):\n    exp=[]\n    # if this does not work -iwo to vk\n    for i in range(len(ck)):\n        mul=ck[i]/(vk[i]-1j*w0)\n        fd=(1-np.exp(-(vk[i]-1j*w0)*t))\n        exp.append(mul*fd)\n    return 2*sum(exp)\ndef gamma4(ck,vk,w0,t):\n    return g4(ck,vk,w0,t) + g2(ck,vk,w0,t)\ndef master_eq_gen(func,ck,vk,w0,t):\n    gamma= func(ck,vk,w0,t).real\n    s=-1j*func(ck,vk,w0,t).imag/2\n    A=sigmap()*sigmam()\n    comm=(spre(A) - spost(A))\n    relax= spre(sigmam())*spost(sigmap()) \n    relax2 = - (spre(A) + spost(A))/2\n    return s*comm + gamma*(relax+relax2)\n</pre>   def solve_c1_system(cks, vks, c1_0, t_span=(0, 50), t_eval=None):     \"\"\"     Solves the system:         dot{c1} = -sum yk         dot{yk} = -vk * yk + ck * c1     Parameters:         cks : list or array of c_k coefficients         vks : list or array of v_k (decay rates)         c1_0 : float, initial condition for c1(t)         t_span : tuple, (t0, tf)         t_eval : array, optional time grid for evaluation     Returns:         t, c1, ys : time array, c1(t) array, y_k(t) array     \"\"\"     cks = np.array(cks, dtype=complex)     vks = np.array(vks, dtype=complex)     N = len(cks)      def system(t, u):         c1 = u[0]         ys = u[1:]                  # Calculate the time derivatives of c1 and yk         dc1_dt = -np.sum(ys)         dys_dt = -(vks) * ys + cks * c1                  # Ensure ys don't go below 0 (clipping to prevent negative values)                 return np.concatenate([[dc1_dt], dys_dt])      # Initial conditions     u0 = np.concatenate([[c1_0],  np.zeros_like(cks)])      # Time grid     if t_eval is None:         t_eval = np.linspace(t_span[0], t_span[1], 1000)      # Solve ODE system using 'RK45' method for better stability     sol = solve_ivp(system, t_span, u0, t_eval=t_eval, method='RK45', vectorized=False)      t = sol.t     c1 = sol.y[0]     ys = sol.y[1:]     return t, c1, ys def g4(ck,vk,w0,t):     # if this does not work -iwo to vk     diff=[]     sam=[]     for i in range(len(ck)):         for j in range(len(ck)):             if i!=j:                 a=1j*w0-vk[i]                 b=vk[j]-1j*w0                 mul=(ck[i]*ck[j])/(a*b)                 uno=np.exp(-t*b)/(vk[i]-vk[j])                 dos=np.exp(-t*(vk[i]+vk[j]-2*1j*w0))/b                 tres=-1/a                 cuatro=(t - 1/a - 1/b + 1/(vk[j]-vk[i]))*np.exp(t*a)                 diff.append(mul*(uno+dos+tres+cuatro))             else:                 a=vk[i]-1j*w0                 mul=(ck[i]**2)/(a**3)                  uno=1-np.exp(-2*t*a)-2*t*np.exp(-t*a)*a                 sam.append(mul*uno)     different= sum(diff)     same=sum(sam)     return 2*(different+same) def g2(ck,vk,w0,t):     exp=[]     # if this does not work -iwo to vk     for i in range(len(ck)):         mul=ck[i]/(vk[i]-1j*w0)         fd=(1-np.exp(-(vk[i]-1j*w0)*t))         exp.append(mul*fd)     return 2*sum(exp) def gamma4(ck,vk,w0,t):     return g4(ck,vk,w0,t) + g2(ck,vk,w0,t) def master_eq_gen(func,ck,vk,w0,t):     gamma= func(ck,vk,w0,t).real     s=-1j*func(ck,vk,w0,t).imag/2     A=sigmap()*sigmam()     comm=(spre(A) - spost(A))     relax= spre(sigmam())*spost(sigmap())      relax2 = - (spre(A) + spost(A))/2     return s*comm + gamma*(relax+relax2) <p>We now construct the Hamiltonian, and prepare or bosonic environment with the structured spectral density</p> In\u00a0[\u00a0]: Copied! <pre>w0=12.1 # the other plot in the article is 12.1*0.992\nH = w0 * sigmap() * sigmam()\nQ = sigmap() + sigmam() # Simulations other than TCL and exact are done without the RWA\nw=np.linspace(0,50,10_000)\nJ=spectral_density(w)\nwp=np.linspace(0,19,10_000)\nJp=spectral_density(wp)\nenv=BosonicEnvironment.from_spectral_density(J,wlist=w,T=0)\nenv2=BosonicEnvironment.from_correlation_function(lambda t:env.correlation_function(t)*np.exp(1j*w0*t),T=0)\nrho0=Qobj([[1,0],[0,0]])\n</pre> w0=12.1 # the other plot in the article is 12.1*0.992 H = w0 * sigmap() * sigmam() Q = sigmap() + sigmam() # Simulations other than TCL and exact are done without the RWA w=np.linspace(0,50,10_000) J=spectral_density(w) wp=np.linspace(0,19,10_000) Jp=spectral_density(wp) env=BosonicEnvironment.from_spectral_density(J,wlist=w,T=0) env2=BosonicEnvironment.from_correlation_function(lambda t:env.correlation_function(t)*np.exp(1j*w0*t),T=0) rho0=Qobj([[1,0],[0,0]])  <p>We approximate it using exponents. In the previous section we considered two different baths, the original one and another where the correlation function is nodified by a phase, one will be passed to the volterra solver, while the other is used for the rest</p> In\u00a0[19]: Copied! <pre>t=np.linspace(0,135,1_000)\nbath,_=env.approximate(\"espira-I\",t,Nr=50)\nbath2,_=env2.approximate(\"espira-I\",t,Nr=50)\n</pre> t=np.linspace(0,135,1_000) bath,_=env.approximate(\"espira-I\",t,Nr=50) bath2,_=env2.approximate(\"espira-I\",t,Nr=50) <p>We now contrast our original and effective environments</p> In\u00a0[20]: Copied! <pre>fig, ax = plt.subplots()\nax.plot(wp/w0,Jp,label='Original SD')\nax.plot(wp/w0,bath.spectral_density(wp),'-.',label='Effective SD')\nax.set_xlabel(r\"$\\omega/\\omega_{0}$\", fontsize=15)\nax.set_ylabel(r\"$J(\\omega)$\", fontsize=15)\nax.set_xlim(0,1.4)\n\n# Add inset\ninset = fig.add_axes([0.24, 0.55, 0.2, 0.15])  # [left, bottom, width, height]\ninset.plot(wp/w0,Jp)\ninset.plot(wp/w0,bath.spectral_density(wp),'-.')\ninset.axvline(x=.992,linestyle='--',color='red',zorder=1)\ninset.axvline(x=1,linestyle='--',color='green',zorder=1)\n\ninset.set_xlim(0.98, 1.02)  \ninset.set_ylim(0.01, 0.04)  \ntick_locations = [0.992,1]\ntick_labels = ['$\\omega_{0}$']\ninset.xaxis.set_major_locator(plt.FixedLocator(tick_locations))\ninset.xaxis.set_major_formatter(plt.FixedFormatter(tick_labels))\ntick_locations = [0.02]\ntick_labels = ['0.02']\ninset.yaxis.set_major_locator(plt.FixedLocator(tick_locations))\ninset.yaxis.set_major_formatter(plt.FixedFormatter(tick_labels))\nax.legend()\n</pre> fig, ax = plt.subplots() ax.plot(wp/w0,Jp,label='Original SD') ax.plot(wp/w0,bath.spectral_density(wp),'-.',label='Effective SD') ax.set_xlabel(r\"$\\omega/\\omega_{0}$\", fontsize=15) ax.set_ylabel(r\"$J(\\omega)$\", fontsize=15) ax.set_xlim(0,1.4)  # Add inset inset = fig.add_axes([0.24, 0.55, 0.2, 0.15])  # [left, bottom, width, height] inset.plot(wp/w0,Jp) inset.plot(wp/w0,bath.spectral_density(wp),'-.') inset.axvline(x=.992,linestyle='--',color='red',zorder=1) inset.axvline(x=1,linestyle='--',color='green',zorder=1)  inset.set_xlim(0.98, 1.02)   inset.set_ylim(0.01, 0.04)   tick_locations = [0.992,1] tick_labels = ['$\\omega_{0}$'] inset.xaxis.set_major_locator(plt.FixedLocator(tick_locations)) inset.xaxis.set_major_formatter(plt.FixedFormatter(tick_labels)) tick_locations = [0.02] tick_labels = ['0.02'] inset.yaxis.set_major_locator(plt.FixedLocator(tick_locations)) inset.yaxis.set_major_formatter(plt.FixedFormatter(tick_labels)) ax.legend()  <pre>&lt;&gt;:18: SyntaxWarning: invalid escape sequence '\\o'\n&lt;&gt;:18: SyntaxWarning: invalid escape sequence '\\o'\n/tmp/ipykernel_20867/301134038.py:18: SyntaxWarning: invalid escape sequence '\\o'\n  tick_labels = ['$\\omega_{0}$']\n</pre> Out[20]: <pre>&lt;matplotlib.legend.Legend at 0x7026e1e21bd0&gt;</pre> In\u00a0[41]: Copied! <pre>tp=np.linspace(0,100,5000)\nfig, (ax_real, ax_imag) = plt.subplots(2, 1, sharex=True) # 2 rows, 1 column, share x-axis\nax_real.plot(tp*w0,bath.correlation_function(tp).real,label='Original CF')\nax_real.plot(tp*w0,env.correlation_function(tp).real,'--',label='Effective CF')\nax_imag.plot(tp*w0,bath.correlation_function(tp).imag)\nax_imag.plot(tp*w0,env.correlation_function(tp).imag,'--')\nax_imag.set_xlim(-0.1,100)\nax_imag.set_ylabel(r\"$\\mathrm{Im}(C(t))$\")\nax_real.set_ylabel(r\"$\\mathrm{Re}(C(t))$\")\nax_imag.set_xlabel(r\"$\\omega_{0} t$\")\n\nax_real.legend()\n</pre> tp=np.linspace(0,100,5000) fig, (ax_real, ax_imag) = plt.subplots(2, 1, sharex=True) # 2 rows, 1 column, share x-axis ax_real.plot(tp*w0,bath.correlation_function(tp).real,label='Original CF') ax_real.plot(tp*w0,env.correlation_function(tp).real,'--',label='Effective CF') ax_imag.plot(tp*w0,bath.correlation_function(tp).imag) ax_imag.plot(tp*w0,env.correlation_function(tp).imag,'--') ax_imag.set_xlim(-0.1,100) ax_imag.set_ylabel(r\"$\\mathrm{Im}(C(t))$\") ax_real.set_ylabel(r\"$\\mathrm{Re}(C(t))$\") ax_imag.set_xlabel(r\"$\\omega_{0} t$\")  ax_real.legend()  Out[41]: <pre>&lt;matplotlib.legend.Legend at 0x70264a418550&gt;</pre> <p>Finally, we perform our simulations</p> In\u00a0[24]: Copied! <pre>c1_0=1\nstart=time.time()\ncks=np.array([i.coefficient for i in bath2.exponents])\nvks=np.array([i.exponent for i in bath2.exponents])\ntmax=20/np.max(J)\nt1, c1, ys = solve_c1_system(cks, vks, c1_0,t_span=(0,tmax))\nend=time.time()\n</pre> c1_0=1 start=time.time() cks=np.array([i.coefficient for i in bath2.exponents]) vks=np.array([i.exponent for i in bath2.exponents]) tmax=20/np.max(J) t1, c1, ys = solve_c1_system(cks, vks, c1_0,t_span=(0,tmax)) end=time.time() In\u00a0[36]: Copied! <pre>rho0=Qobj([[1,0],[0,0]])\nstart2=time.time()\ncum=cumulant.csolve(Hsys=H,Qs=[Q],baths=[bath],t=t1,matsubara=True,cython=False,ls=True)\ncum_re=cum.evolution(rho0)\nend2=time.time()\nstart3=time.time()\nred=redfield.redfield(Hsys=H,Qs=[Q],baths=[bath],t=t1,matsubara=True,ls=True)\nred_re=red.evolution(rho0)\nend3=time.time()\n</pre> rho0=Qobj([[1,0],[0,0]]) start2=time.time() cum=cumulant.csolve(Hsys=H,Qs=[Q],baths=[bath],t=t1,matsubara=True,cython=False,ls=True) cum_re=cum.evolution(rho0) end2=time.time() start3=time.time() red=redfield.redfield(Hsys=H,Qs=[Q],baths=[bath],t=t1,matsubara=True,ls=True) red_re=red.evolution(rho0) end3=time.time()  <pre>Calculating Integrals ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [00:00&lt;00:00, 84.93it/s]\nCalculating time independent matrices...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [00:00&lt;00:00, 3920.83it/s]\nCalculating time dependent generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [00:00&lt;00:00, 125.26it/s]\nComputing Exponential of Generators . . . .: 1000it [00:00, 3626.00it/s]\n</pre> <pre>Started integration and Generator Calculations\nFinished integration and Generator Calculations\nComputation Time:0.09030461311340332\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nStarted interpolation\nFinished interpolation\nComputation Time:0.002148866653442383\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nStarted Solving the differential equation\nFinished Solving the differential equation\nComputation Time:0.0584568977355957\n</pre> In\u00a0[34]: Copied! <pre>def f(t, y):\n    return master_eq_gen(gamma4,cks2,vks2,w0,t).full()@y\nprint(\"Started Solving the differential equation\")\ntcl4 = solve_ivp(f, [0, t1[-1]],\n                    y0,\n                    t_eval=t1, method=\"BDF\")\n</pre> def f(t, y):     return master_eq_gen(gamma4,cks2,vks2,w0,t).full()@y print(\"Started Solving the differential equation\") tcl4 = solve_ivp(f, [0, t1[-1]],                     y0,                     t_eval=t1, method=\"BDF\") <pre>Started Solving the differential equation\n</pre> In\u00a0[38]: Copied! <pre>heom_solution = heom.heomsolve(H, (bath,Q), 2, rho0, t1)\n\n# --- Transform to interaction picture ---\n\nUs = [(-1j * H * t).expm() for t in t1]\nheom_states = [U * state * U.dag() for (U, state) in zip(Us, heom_solution.states)]\n</pre> heom_solution = heom.heomsolve(H, (bath,Q), 2, rho0, t1)  # --- Transform to interaction picture ---  Us = [(-1j * H * t).expm() for t in t1] heom_states = [U * state * U.dag() for (U, state) in zip(Us, heom_solution.states)] <pre>10.0%. Run time:   3.17s. Est. time left: 00:00:00:28\n20.0%. Run time:   6.78s. Est. time left: 00:00:00:27\n30.0%. Run time:   9.60s. Est. time left: 00:00:00:22\n40.0%. Run time:  12.34s. Est. time left: 00:00:00:18\n50.1%. Run time:  15.01s. Est. time left: 00:00:00:14\n60.1%. Run time:  17.67s. Est. time left: 00:00:00:11\n70.1%. Run time:  20.31s. Est. time left: 00:00:00:08\n80.1%. Run time:  22.90s. Est. time left: 00:00:00:05\n90.1%. Run time:  25.51s. Est. time left: 00:00:00:02\n100.0%. Run time:  28.21s. Est. time left: 00:00:00:00\nTotal run time:  28.22s\n</pre> <p>Now, we observe the result</p> In\u00a0[\u00a0]: Copied! <pre>fig, ax = plt.subplots()\nax.plot(t1/w0, abs(c1)**2 , label=rf'Exact solution')\nax.plot(t1/w0, np.array([i[0,0] for i in heom_states]), linestyle=\"--\",label='HEOM')\nax.plot(t1/w0, np.array([i[0,0] for i in cum_re]), linestyle=\"-.\",label='Cumulant')\nax.plot(t1/w0, tcl4.y[0],linestyle=\"None\",marker=\"v\",markevery=15,markersize=10,label='TCL4')\nax.legend()\nax.set_xlabel(r\"$\\omega_{0}t$\", fontsize=15)\nax.set_ylabel(r\"$\\rho_{11}(t)$\", fontsize=15)\nplt.xlim(0,7)\nplt.show()\n</pre> fig, ax = plt.subplots() ax.plot(t1/w0, abs(c1)**2 , label=rf'Exact solution') ax.plot(t1/w0, np.array([i[0,0] for i in heom_states]), linestyle=\"--\",label='HEOM') ax.plot(t1/w0, np.array([i[0,0] for i in cum_re]), linestyle=\"-.\",label='Cumulant') ax.plot(t1/w0, tcl4.y[0],linestyle=\"None\",marker=\"v\",markevery=15,markersize=10,label='TCL4') ax.legend() ax.set_xlabel(r\"$\\omega_{0}t$\", fontsize=15) ax.set_ylabel(r\"$\\rho_{11}(t)$\", fontsize=15) plt.xlim(0,7) plt.show() <p>We can see the approximate solutions are really close to the exact one.</p>"},{"location":"damped_jc/#example-5-structured-environments-and-tcl","title":"Example 5:  Structured environments and TCL\u00b6","text":"<p>This example provides the necessary code to reproduce the calculations from example 4 in 2, where the Hamiltonian is given by</p> <p>\\begin{align} \tH = \\omega_{0} \\sigma_{+} \\sigma_{-}                      \t+ \\sum_{k} \\omega_{k} b_{k}^{\\dagger}b_{k}              \t+ \\sigma_{+} \\otimes \\sum_{k} g_{k} b_{k} +H.C . \\end{align} For TCL and the RWA exact solution and \\begin{align} \tH = \\omega_{0} \\sigma_{+} \\sigma_{-}                      \t+ \\sum_{k} \\omega_{k} b_{k}^{\\dagger}b_{k}              \t+ \\sigma_{x} \\sum_{k} g_{k} (b_{k} +b_{k}^{\\dagger}) \\end{align} For the methods supported by this package and QutiP. The main pourpose of this example is to show the usage of Non-Markovian master equations with structured environments as well as to show how the exponent approximation can be used with TCL and Volterra equations. We first begin by importing the necessary packages</p>"},{"location":"example_qutip/","title":"Example 1: The Refined Weak Coupling/ Cumulant equation for a spin boson model with an overdamped spectral density","text":"In\u00a0[1]: Copied! <pre>from nmm import csolve,OverdampedBath\nfrom qutip import Qobj,sigmaz,sigmax,brmesolve,heom,DrudeLorentzEnvironment\nimport numpy as np\nfrom scipy.integrate import quad_vec\nfrom scipy import linalg\nfrom tqdm import tqdm\nimport matplotlib.pyplot as plt\n</pre> from nmm import csolve,OverdampedBath from qutip import Qobj,sigmaz,sigmax,brmesolve,heom,DrudeLorentzEnvironment import numpy as np from scipy.integrate import quad_vec from scipy import linalg from tqdm import tqdm import matplotlib.pyplot as plt <p>We now specify the parameters of our simulation</p> In\u00a0[2]: Copied! <pre>w0 = 1\nalpha = 0.05\ngamma = 5*w0\nT = 1*w0\ntf = 80\nt=np.linspace(0,tf,100)\nHsys = sigmaz()/2\nQ = sigmax()\n</pre> w0 = 1 alpha = 0.05 gamma = 5*w0 T = 1*w0 tf = 80 t=np.linspace(0,tf,100) Hsys = sigmaz()/2 Q = sigmax() <p>The refined weak coupling or cumulant equation needs the spectral density to calculate the decay rates, to make simulation easy we included the spectral densities among other bath related functions in bath classes, in this example we want to use a Drude Lorentz overdamped spectral density, so we initialize an OverdampedBath</p> In\u00a0[3]: Copied! <pre>bath=DrudeLorentzEnvironment(T,alpha,gamma)\n</pre> bath=DrudeLorentzEnvironment(T,alpha,gamma) <p>Next we initialize the csolve which is the solver of the cumulant equation, it requires the time grid for our simulation, the system Hamiltonian, The coupling operator $Q$, andd the bath object</p> In\u00a0[4]: Copied! <pre>cc = csolve(Hsys,t ,[bath], [Q],cython=False)\n</pre> cc = csolve(Hsys,t ,[bath], [Q],cython=False) <p>We now specify our inital state</p> In\u00a0[5]: Copied! <pre>rho0=0.5*Qobj([[1,1],[1,1]])\nrho0\n</pre> rho0=0.5*Qobj([[1,1],[1,1]]) rho0 Out[5]:  Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True$$\\left(\\begin{array}{cc}0.500 &amp; 0.500\\\\0.500 &amp; 0.500\\end{array}\\right)$$  <p>We now simply obtain the evolution using the cumulant equation</p> In\u00a0[6]: Copied! <pre>result=cc.evolution(rho0)\n</pre> result=cc.evolution(rho0) <pre>WARNING:2025-06-29 17:02:37,557:jax._src.xla_bridge:969: An NVIDIA GPU may be present on this machine, but a CUDA-enabled jaxlib is not installed. Falling back to cpu.\nCalculating Integrals ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [00:11&lt;00:00,  2.96s/it]\nCalculating time independent matrices...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [00:00&lt;00:00, 2137.77it/s]\nCalculating time dependent generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [00:00&lt;00:00, 1338.11it/s]\nComputing Exponential of Generators . . . .: 100it [00:00, 2658.21it/s]\n</pre> <p>The evolution of the cumulant equation is given in the interaction picture, to get it in the Schrodinger picture a rotation is needed</p> In\u00a0[7]: Copied! <pre>def rotation(data,H, t):\n    try:\n        rotated = [\n            (-1j * H * t[i]).expm()\n            * data[i]\n            * (1j * H * t[i]).expm()\n            for i in range(len(t))\n        ]\n    except:\n        rotated = [\n            (-1j * H * t[i]).expm()\n            * qt.Qobj(data[i],dims=H.dims)\n            * (1j * H * t[i]).expm()\n            for i in range(len(t))\n        ]\n    return rotated\n</pre> def rotation(data,H, t):     try:         rotated = [             (-1j * H * t[i]).expm()             * data[i]             * (1j * H * t[i]).expm()             for i in range(len(t))         ]     except:         rotated = [             (-1j * H * t[i]).expm()             * qt.Qobj(data[i],dims=H.dims)             * (1j * H * t[i]).expm()             for i in range(len(t))         ]     return rotated In\u00a0[8]: Copied! <pre>result=rotation(result,Hsys,t)\n</pre> result=rotation(result,Hsys,t)  <p>We know solve the same system with the Hierarchical Equations of motion (HEOM) we use Qutip's implementation. Details can be found here</p> In\u00a0[9]: Copied! <pre>bathh = bath.approximate('pade',Nk=4)\nresult_h = heom.heomsolve(Hsys, [bathh,Q], 3,rho0,t)\n</pre> bathh = bath.approximate('pade',Nk=4) result_h = heom.heomsolve(Hsys, [bathh,Q], 3,rho0,t) <pre>10.1%. Run time:   0.04s. Est. time left: 00:00:00:00\n20.2%. Run time:   0.08s. Est. time left: 00:00:00:00\n30.3%. Run time:   0.11s. Est. time left: 00:00:00:00\n40.4%. Run time:   0.14s. Est. time left: 00:00:00:00\n50.5%. Run time:   0.18s. Est. time left: 00:00:00:00\n60.6%. Run time:   0.21s. Est. time left: 00:00:00:00\n70.7%. Run time:   0.24s. Est. time left: 00:00:00:00\n80.8%. Run time:   0.28s. Est. time left: 00:00:00:00\n90.9%. Run time:   0.31s. Est. time left: 00:00:00:00\n100.0%. Run time:   0.34s. Est. time left: 00:00:00:00\nTotal run time:   0.34s\n</pre> <p>and finally let us use the Bloch-Redfield equation which uses a similar level of approximation as the Refined Weak Coupling/Cumulant Equation</p> In\u00a0[10]: Copied! <pre>a_ops = [[Q, bath]]\nresultBR = brmesolve(Hsys, rho0, t, a_ops=a_ops,sec_cutoff=-1)\n</pre> a_ops = [[Q, bath]] resultBR = brmesolve(Hsys, rho0, t, a_ops=a_ops,sec_cutoff=-1) In\u00a0[11]: Copied! <pre>#Auxiliary function for plotting\ndef population(den, a, b):\n    return [den[i][a, b] for i in range(len(den))]\n</pre> #Auxiliary function for plotting def population(den, a, b):     return [den[i][a, b] for i in range(len(den))] In\u00a0[12]: Copied! <pre>plt.plot(t,population(result_h.states,0,0),label='HEOM')\nplt.plot(t,population(resultBR.states,0,0),label='BR')\nplt.plot(t,population(result,0,0),'r-.',label='Cumulant/Refined Weak Coupling')\nplt.ylabel(r'$\\rho_{11}$',fontsize=16)\nplt.xlabel(r't',fontsize=16)\nplt.legend()\nplt.show()\n</pre> plt.plot(t,population(result_h.states,0,0),label='HEOM') plt.plot(t,population(resultBR.states,0,0),label='BR') plt.plot(t,population(result,0,0),'r-.',label='Cumulant/Refined Weak Coupling') plt.ylabel(r'$\\rho_{11}$',fontsize=16) plt.xlabel(r't',fontsize=16) plt.legend() plt.show() <pre>/home/gerardo/.pyenv/versions/3.13.0/envs/qutip-dev/lib/python3.13/site-packages/matplotlib/cbook.py:1709: ComplexWarning: Casting complex values to real discards the imaginary part\n  return math.isfinite(val)\n/home/gerardo/.pyenv/versions/3.13.0/envs/qutip-dev/lib/python3.13/site-packages/matplotlib/cbook.py:1345: ComplexWarning: Casting complex values to real discards the imaginary part\n  return np.asarray(x, float)\n</pre> In\u00a0[13]: Copied! <pre>def bose(\u03bd, T):\n    if T == 0:\n        return 0\n    if \u03bd == 0:\n        return 0\n    return np.exp(-\u03bd / T) / (1-np.exp(-\u03bd / T))\n\n\ndef spectral_density(w, lam, gamma):\n    return 2 * w * lam * gamma / (gamma**2 + w**2)/np.pi\n\n\ndef \u03b3(\u03bd, w, w1, T, t, gamma, lam):\n    var = (\n        t * t * np.exp(1j * (w - w1) / 2 * t) *\n        spectral_density(\u03bd, lam, gamma) *\n        (np.sinc((w - \u03bd) / (2 * np.pi) * t) * np.sinc((w1 - \u03bd) / (2 * np.pi) * t)) *\n        (bose(\u03bd, T) + 1))\n    var += (\n        t\n        * t\n        * np.exp(1j * (w - w1) / 2 * t)\n        * spectral_density(\u03bd, lam, gamma)\n        * (np.sinc((w + \u03bd) / (2 * np.pi) * t) * np.sinc((w1 + \u03bd) / (2 * np.pi) * t))\n        * bose(\u03bd, T)\n    )\n    return var\n\n\ndef \u0393plus(w, T, t, wc, lam, \u03f5): return quad_vec(\n    lambda \u03bd: \u03b3(\u03bd, w, w, T, t, wc, lam),\n    0,\n    np.inf,\n    epsabs=\u03f5,\n    epsrel=\u03f5,\n    quadrature=\"gk15\",\n)[0]\n\n\ndef \u0393minus(w, T, t, wc, lam, \u03f5): return quad_vec(\n    lambda \u03bd: \u03b3(\u03bd, -w, -w, T, t, wc, lam),\n    0,\n    np.inf,\n    quadrature=\"gk15\",\n    epsabs=\u03f5,\n    epsrel=\u03f5,\n)[0]\n\n\ndef \u0393plusminus(w, T, t, wc, lam, \u03f5): return quad_vec(\n    lambda \u03bd: \u03b3(\u03bd, w, -w, T, t, wc, lam),\n    0,\n    np.inf,\n    epsabs=\u03f5,\n    epsrel=\u03f5,\n)[0]\n\n\ndef \u0393zplus(w, T, t, wc, lam, \u03f5): return quad_vec(\n    lambda \u03bd: \u03b3(\u03bd, 0, w, T, t, wc, lam),\n    0,\n    np.inf,\n    quadrature=\"gk21\",\n    epsabs=\u03f5,\n    epsrel=\u03f5,\n)[0]\n\n\ndef \u0393zminus(w, T, t, wc, lam, \u03f5): return quad_vec(\n    lambda \u03bd: \u03b3(\u03bd, 0, -w, T, t, wc, lam),\n    0,\n    np.inf,\n    quadrature=\"gk21\",\n    epsabs=\u03f5,\n    epsrel=\u03f5,\n)[0]\n\n\ndef \u0393zz(w, T, t, wc, lam, \u03f5): return quad_vec(\n    lambda \u03bd: \u03b3(\u03bd, 0, 0, T, t, wc, lam),\n    0,\n    np.inf,\n    quadrature=\"gk21\",\n    epsabs=\u03f5,\n    epsrel=\u03f5,\n)[0]\n\n\n\ndef M(w, T, lam, t, f1, f2, f3, wc, \u03f5):\n    f = f1 - 1j * f2\n    gplus = (np.abs(f) ** 2) * \u0393plus(w, T, t, wc, lam, \u03f5)\n    gminus = (np.abs(f) ** 2) * \u0393minus(w, T, t, wc, lam, \u03f5)\n    gzplus = np.conjugate(f) * f3 * \u0393zplus(w, T, t, wc, lam, \u03f5)\n    gzminus = f * f3 * \u0393zminus(w, T, t, wc, lam, \u03f5)\n    gamma = gplus + gminus\n    l = np.conjugate(gzplus) + gzminus\n    A = np.conjugate(gzplus) - gzminus\n    plusminus = f**2 * \u0393plusminus(w, T, t, wc, lam, \u03f5)\n    gammazz = 2 * f3**2 * \u0393zz(w, T, t, wc, lam, \u03f5)\n    xiz = 0  # These are included to show the full matrix as in 1\n    xi = 0  # but LS corrections are not included here\n    matriz = np.array(\n        [\n            [-gamma, xiz * f2 + np.real(l), -xiz * f1 - np.imag(l)],\n            [\n                np.real(l) - f2 * xiz,\n                np.real(plusminus) - (gamma / 2) - gammazz,\n                -xi - np.imag(plusminus),\n            ],\n            [\n                -np.imag(l) + f1 * xiz,\n                xi - np.imag(plusminus),\n                - np.real(plusminus) - (gamma / 2) - gammazz,\n            ],\n        ]\n    )\n    r = [\n        (gminus - gplus) / 2,\n        np.real(A),\n        -np.imag(A),\n    ]\n    return matriz, r\n\n\ndef dynamics(w, T, t, lam, f1, f2, f3, wc, \u03f5, a):\n    s1 = np.array([[0, 1], [1, 0]])\n    s2 = np.array([[0, -1j], [1j, 0]])\n    s3 = np.array([[1, 0], [0, -1]])\n    if t == 0:\n        return (np.eye(2) / 2) + a[0] * s3 + a[2] * s2 + a[1] * s1\n    m, r = M(w, T, lam, t, f1, f2, f3, wc, \u03f5)\n    if (f1 == f2) &amp; (f2 == 0):\n        m = m[1:, 1:]\n        # print(m.shape)\n        exponential = linalg.expm(m)\n        pauli_coeff = (exponential - np.eye(2)) @ np.linalg.inv(m) @ r[1:]\n        with_pauli = pauli_coeff[0] * s1 + pauli_coeff[1] * s2\n        transient = exponential @ a[1:]\n        transient_base = transient[0] * s1 + transient[1] * s2\n        total = (np.eye(2) / 2) + transient_base + with_pauli + a[0] * s3\n        return total\n    exponential = linalg.expm(m)\n    pauli_coeff = (exponential - np.eye(3)) @ np.linalg.inv(m) @ r\n    with_pauli = pauli_coeff[0] * s3 + pauli_coeff[1] * s1 + pauli_coeff[2] * s2\n    transient = exponential @ a\n    transient_base = transient[0] * s3 + transient[1] * s1 + transient[2] * s2\n    total = (np.eye(2) / 2) + transient_base + with_pauli\n    return total\n\ndef rotation(data, t):\n    sz = np.array([[1, 0], [0, -1]])\n    rotated = [\n        linalg.expm(-(1j * sz / 2) * t[i])\n        @ np.array(data)[i]\n        @ linalg.expm((1j * sz / 2) * t[i])\n        for i in tqdm(range(len(t)), desc=f\"Computing for all t, currently on \")\n    ]\n    return rotated\n\ndef cumulant(\n    t, w, T, lam, f1, f2, f3, a, b, c, gamma, \u03f5, dm=True, l=10, t0=0\n):\n    t = np.linspace(t0, t, l)\n    data = [\n        dynamics(w, T, i, lam, f1, f2, f3, gamma, \u03f5, [a, b, c])\n        for i in tqdm(t, desc=f\"Computing for all t, currently on \")\n    ]\n    data = rotation(data, t)\n    if dm:\n        return data\n    \u03c111 = np.array([data[i][0, 0] for i in range(len(data))])\n    \u03c112 = np.array([data[i][0, 1] for i in range(len(data))])\n    \u03c121 = np.array([data[i][1, 0] for i in range(len(data))])\n    \u03c122 = np.array([data[i][1, 1] for i in range(len(data))])\n    return \u03c111, \u03c112, \u03c121, \u03c122\n</pre> def bose(\u03bd, T):     if T == 0:         return 0     if \u03bd == 0:         return 0     return np.exp(-\u03bd / T) / (1-np.exp(-\u03bd / T))   def spectral_density(w, lam, gamma):     return 2 * w * lam * gamma / (gamma**2 + w**2)/np.pi   def \u03b3(\u03bd, w, w1, T, t, gamma, lam):     var = (         t * t * np.exp(1j * (w - w1) / 2 * t) *         spectral_density(\u03bd, lam, gamma) *         (np.sinc((w - \u03bd) / (2 * np.pi) * t) * np.sinc((w1 - \u03bd) / (2 * np.pi) * t)) *         (bose(\u03bd, T) + 1))     var += (         t         * t         * np.exp(1j * (w - w1) / 2 * t)         * spectral_density(\u03bd, lam, gamma)         * (np.sinc((w + \u03bd) / (2 * np.pi) * t) * np.sinc((w1 + \u03bd) / (2 * np.pi) * t))         * bose(\u03bd, T)     )     return var   def \u0393plus(w, T, t, wc, lam, \u03f5): return quad_vec(     lambda \u03bd: \u03b3(\u03bd, w, w, T, t, wc, lam),     0,     np.inf,     epsabs=\u03f5,     epsrel=\u03f5,     quadrature=\"gk15\", )[0]   def \u0393minus(w, T, t, wc, lam, \u03f5): return quad_vec(     lambda \u03bd: \u03b3(\u03bd, -w, -w, T, t, wc, lam),     0,     np.inf,     quadrature=\"gk15\",     epsabs=\u03f5,     epsrel=\u03f5, )[0]   def \u0393plusminus(w, T, t, wc, lam, \u03f5): return quad_vec(     lambda \u03bd: \u03b3(\u03bd, w, -w, T, t, wc, lam),     0,     np.inf,     epsabs=\u03f5,     epsrel=\u03f5, )[0]   def \u0393zplus(w, T, t, wc, lam, \u03f5): return quad_vec(     lambda \u03bd: \u03b3(\u03bd, 0, w, T, t, wc, lam),     0,     np.inf,     quadrature=\"gk21\",     epsabs=\u03f5,     epsrel=\u03f5, )[0]   def \u0393zminus(w, T, t, wc, lam, \u03f5): return quad_vec(     lambda \u03bd: \u03b3(\u03bd, 0, -w, T, t, wc, lam),     0,     np.inf,     quadrature=\"gk21\",     epsabs=\u03f5,     epsrel=\u03f5, )[0]   def \u0393zz(w, T, t, wc, lam, \u03f5): return quad_vec(     lambda \u03bd: \u03b3(\u03bd, 0, 0, T, t, wc, lam),     0,     np.inf,     quadrature=\"gk21\",     epsabs=\u03f5,     epsrel=\u03f5, )[0]    def M(w, T, lam, t, f1, f2, f3, wc, \u03f5):     f = f1 - 1j * f2     gplus = (np.abs(f) ** 2) * \u0393plus(w, T, t, wc, lam, \u03f5)     gminus = (np.abs(f) ** 2) * \u0393minus(w, T, t, wc, lam, \u03f5)     gzplus = np.conjugate(f) * f3 * \u0393zplus(w, T, t, wc, lam, \u03f5)     gzminus = f * f3 * \u0393zminus(w, T, t, wc, lam, \u03f5)     gamma = gplus + gminus     l = np.conjugate(gzplus) + gzminus     A = np.conjugate(gzplus) - gzminus     plusminus = f**2 * \u0393plusminus(w, T, t, wc, lam, \u03f5)     gammazz = 2 * f3**2 * \u0393zz(w, T, t, wc, lam, \u03f5)     xiz = 0  # These are included to show the full matrix as in 1     xi = 0  # but LS corrections are not included here     matriz = np.array(         [             [-gamma, xiz * f2 + np.real(l), -xiz * f1 - np.imag(l)],             [                 np.real(l) - f2 * xiz,                 np.real(plusminus) - (gamma / 2) - gammazz,                 -xi - np.imag(plusminus),             ],             [                 -np.imag(l) + f1 * xiz,                 xi - np.imag(plusminus),                 - np.real(plusminus) - (gamma / 2) - gammazz,             ],         ]     )     r = [         (gminus - gplus) / 2,         np.real(A),         -np.imag(A),     ]     return matriz, r   def dynamics(w, T, t, lam, f1, f2, f3, wc, \u03f5, a):     s1 = np.array([[0, 1], [1, 0]])     s2 = np.array([[0, -1j], [1j, 0]])     s3 = np.array([[1, 0], [0, -1]])     if t == 0:         return (np.eye(2) / 2) + a[0] * s3 + a[2] * s2 + a[1] * s1     m, r = M(w, T, lam, t, f1, f2, f3, wc, \u03f5)     if (f1 == f2) &amp; (f2 == 0):         m = m[1:, 1:]         # print(m.shape)         exponential = linalg.expm(m)         pauli_coeff = (exponential - np.eye(2)) @ np.linalg.inv(m) @ r[1:]         with_pauli = pauli_coeff[0] * s1 + pauli_coeff[1] * s2         transient = exponential @ a[1:]         transient_base = transient[0] * s1 + transient[1] * s2         total = (np.eye(2) / 2) + transient_base + with_pauli + a[0] * s3         return total     exponential = linalg.expm(m)     pauli_coeff = (exponential - np.eye(3)) @ np.linalg.inv(m) @ r     with_pauli = pauli_coeff[0] * s3 + pauli_coeff[1] * s1 + pauli_coeff[2] * s2     transient = exponential @ a     transient_base = transient[0] * s3 + transient[1] * s1 + transient[2] * s2     total = (np.eye(2) / 2) + transient_base + with_pauli     return total  def rotation(data, t):     sz = np.array([[1, 0], [0, -1]])     rotated = [         linalg.expm(-(1j * sz / 2) * t[i])         @ np.array(data)[i]         @ linalg.expm((1j * sz / 2) * t[i])         for i in tqdm(range(len(t)), desc=f\"Computing for all t, currently on \")     ]     return rotated  def cumulant(     t, w, T, lam, f1, f2, f3, a, b, c, gamma, \u03f5, dm=True, l=10, t0=0 ):     t = np.linspace(t0, t, l)     data = [         dynamics(w, T, i, lam, f1, f2, f3, gamma, \u03f5, [a, b, c])         for i in tqdm(t, desc=f\"Computing for all t, currently on \")     ]     data = rotation(data, t)     if dm:         return data     \u03c111 = np.array([data[i][0, 0] for i in range(len(data))])     \u03c112 = np.array([data[i][0, 1] for i in range(len(data))])     \u03c121 = np.array([data[i][1, 0] for i in range(len(data))])     \u03c122 = np.array([data[i][1, 1] for i in range(len(data))])     return \u03c111, \u03c112, \u03c121, \u03c122 In\u00a0[14]: Copied! <pre>cum2=cumulant(t[-1],w0,T,alpha,1,0,0,0,0.5,0,gamma,1e-3)\n</pre> cum2=cumulant(t[-1],w0,T,alpha,1,0,0,0,0.5,0,gamma,1e-3) <pre>Computing for all t, currently on : 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [00:07&lt;00:00,  1.37it/s]\nComputing for all t, currently on : 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [00:00&lt;00:00, 9738.34it/s]\n</pre> In\u00a0[15]: Copied! <pre>t2=np.linspace(0,t[-1],len(cum2))\nplt.scatter(t2,population(cum2,0,1),label='Cumulant in Linear Map Form')\nplt.plot(t,population(result_h.states,0,1),label='HEOM')\nplt.plot(t,population(resultBR.states,0,1),label='BR')\nplt.plot(t,population(result,0,1),'r-.',label='Cumulant/Refined Weak Coupling')\nplt.ylabel(r'Re($\\rho_{12}$)',fontsize=16)\nplt.xlabel(r't',fontsize=16)\nplt.legend()\nplt.show()\n</pre> t2=np.linspace(0,t[-1],len(cum2)) plt.scatter(t2,population(cum2,0,1),label='Cumulant in Linear Map Form') plt.plot(t,population(result_h.states,0,1),label='HEOM') plt.plot(t,population(resultBR.states,0,1),label='BR') plt.plot(t,population(result,0,1),'r-.',label='Cumulant/Refined Weak Coupling') plt.ylabel(r'Re($\\rho_{12}$)',fontsize=16) plt.xlabel(r't',fontsize=16) plt.legend() plt.show() <pre>/home/gerardo/.pyenv/versions/3.13.0/envs/qutip-dev/lib/python3.13/site-packages/matplotlib/collections.py:200: ComplexWarning: Casting complex values to real discards the imaginary part\n  offsets = np.asanyarray(offsets, float)\n</pre> In\u00a0[16]: Copied! <pre>plt.scatter(t2,population(cum2,0,0),label='Cumulant in Linear Map Form')\nplt.plot(t,population(result_h.states,0,0),label='HEOM')\nplt.plot(t,population(resultBR.states,0,0),label='BR')\nplt.plot(t,population(result,0,0),'r-.',label='Cumulant/Refined Weak Coupling')\nplt.ylabel(r'$\\rho_{11}$',fontsize=16)\nplt.xlabel(r't',fontsize=16)\nplt.legend()\nplt.show()\n</pre> plt.scatter(t2,population(cum2,0,0),label='Cumulant in Linear Map Form') plt.plot(t,population(result_h.states,0,0),label='HEOM') plt.plot(t,population(resultBR.states,0,0),label='BR') plt.plot(t,population(result,0,0),'r-.',label='Cumulant/Refined Weak Coupling') plt.ylabel(r'$\\rho_{11}$',fontsize=16) plt.xlabel(r't',fontsize=16) plt.legend() plt.show()"},{"location":"example_qutip/#example-1-the-refined-weak-coupling-cumulant-equation-for-a-spin-boson-model-with-an-overdamped-spectral-density","title":"Example 1: The Refined Weak Coupling/ Cumulant equation for a spin boson model with an overdamped spectral density\u00b6","text":"<p>This example provides the necessary code to reproduce the calculations from 1, where the Hamiltonian of the spin-boson model is given by</p> <p>\\begin{align}      H = \\underbrace{\\frac{\\omega_{0}}{2} \\sigma_{z}}_{H_S} + \\underbrace{\\sum_{k} w_{k} a_{k}^{\\dagger} a_{k}}_{H_B} + \\underbrace{\\sum_{k} g_k (f_1 \\sigma_{x}+f_2 \\sigma_{y} +f_3 \\sigma_{z}) (a_{k}+a_{k}^{\\dagger})}_{H_I} \\end{align}</p> <p>We first begin by importing the necessary packages</p>"},{"location":"example_qutip/#let-us-compare-with-the-semi-analytical-form-of-the-cumulantrefined-weak-coupling-for-a-qubit-from-1","title":"Let us compare with the semi-analytical form of the cumulant/refined weak coupling for a qubit from  1\u00b6","text":""},{"location":"kerr_example/","title":"Example 4: A Kerr nonlinearity in an Ohmic enviroment","text":"In\u00a0[1]: Copied! <pre>import qutip as qt \nimport numpy as np\nfrom qutip.core.environment import UnderDampedEnvironment\nfrom nmm.redfield import redfield\nfrom nmm import csolve\nfrom scipy import linalg\nfrom qutip.solver.heom import HEOMSolver\nfrom qutip.solver.heom import BosonicBath,HEOMSolver,BathExponent\nfrom time import time\nimport matplotlib.pyplot as plt\n# to get cumulant from Interaction to Schrodinger picture\ndef rotation(data, t, Hsys):\n    try:\n        rotated = [\n            (-1j * Hsys * t[i]).expm()\n            * data[i]\n            * (1j * Hsys * t[i]).expm()\n            for i in range(len(t))\n        ]\n    except:\n        rotated = [\n            (-1j * Hsys * t[i]).expm()\n            * qt.Qobj(data[i],dims=Hsys.dims)\n            * (1j * Hsys * t[i]).expm()\n            for i in range(len(t))\n        ]\n        \n    return rotated\n</pre> import qutip as qt  import numpy as np from qutip.core.environment import UnderDampedEnvironment from nmm.redfield import redfield from nmm import csolve from scipy import linalg from qutip.solver.heom import HEOMSolver from qutip.solver.heom import BosonicBath,HEOMSolver,BathExponent from time import time import matplotlib.pyplot as plt # to get cumulant from Interaction to Schrodinger picture def rotation(data, t, Hsys):     try:         rotated = [             (-1j * Hsys * t[i]).expm()             * data[i]             * (1j * Hsys * t[i]).expm()             for i in range(len(t))         ]     except:         rotated = [             (-1j * Hsys * t[i]).expm()             * qt.Qobj(data[i],dims=Hsys.dims)             * (1j * Hsys * t[i]).expm()             for i in range(len(t))         ]              return rotated <p>We then specify the parameters for the simulation, and construct the Hamiltonian</p> In\u00a0[2]: Copied! <pre>N = 10\nw0=1\nchi = 0.5 # Kerr-nonlinearity\n# operators: the annihilation operator of the field\na = qt.destroy(N)\n\n# and we'll also need the following operators in calculation of\n# expectation values when visualizing the dynamics\nn = qt.num(N)\nx = a + a.dag()\np = -1j * (a - a.dag())\nH = w0*a.dag()*a +0.5 * chi * a.dag() * a.dag() * a * a\nQ = x #coupling operator to the environment\n</pre> N = 10 w0=1 chi = 0.5 # Kerr-nonlinearity # operators: the annihilation operator of the field a = qt.destroy(N)  # and we'll also need the following operators in calculation of # expectation values when visualizing the dynamics n = qt.num(N) x = a + a.dag() p = -1j * (a - a.dag()) H = w0*a.dag()*a +0.5 * chi * a.dag() * a.dag() * a * a Q = x #coupling operator to the environment  <p>We then construct our initial state which will be a mixture of coherent states</p> In\u00a0[3]: Copied! <pre># qubit-qubit and qubit-bath coupling strengths\npsi0 =(qt.coherent(N, -2.0) - qt.coherent(N, 2.0)) / np.sqrt(2)\n\nrho0=qt.ket2dm(psi0)\nrho0/=rho0.tr()\n\nrho0.dims=H.dims\n</pre> # qubit-qubit and qubit-bath coupling strengths psi0 =(qt.coherent(N, -2.0) - qt.coherent(N, 2.0)) / np.sqrt(2)  rho0=qt.ket2dm(psi0) rho0/=rho0.tr()  rho0.dims=H.dims <p>We now prepare our approximated environment</p> In\u00a0[4]: Copied! <pre>tfit=np.linspace(0,15,2000)\nlam = 0.25*np.pi#bath1\nbathr=qt.core.environment.OhmicEnvironment(T=0.1*w0,alpha=lam*chi,wc=w0,s=1)\nbath1corr,finfo1=bathr.approximate('cf',tfit,tag=\"bath 1\",Ni_max=4,Nr_max=3,maxfev=1e8,target_rmse=None,sigma=1e-7)\nprint(finfo1['summary'])\noptions = {'nsteps':150_000, 'store_states':True,'store_ados':True,'rtol':1e-12,'atol':1e-12}\n</pre> tfit=np.linspace(0,15,2000) lam = 0.25*np.pi#bath1 bathr=qt.core.environment.OhmicEnvironment(T=0.1*w0,alpha=lam*chi,wc=w0,s=1) bath1corr,finfo1=bathr.approximate('cf',tfit,tag=\"bath 1\",Ni_max=4,Nr_max=3,maxfev=1e8,target_rmse=None,sigma=1e-7) print(finfo1['summary']) options = {'nsteps':150_000, 'store_states':True,'store_ados':True,'rtol':1e-12,'atol':1e-12} <pre>Correlation function fit:\n\nResult of fitting the real part of                        |Result of fitting the imaginary part                       \nthe correlation function with 3 terms:                    |of the correlation function with 4 terms:                  \n                                                          |                                                           \n Parameters|   ckr    |   vkr    |  vki                   | Parameters|   ckr    |   vkr    |  vki                    \n 1         | 1.31e+00 |-2.09e+00 |1.03e+00                | 1         | 6.76e-02 |-4.30e+00 |3.95e+00                 \n 2         |-2.57e+00 |-1.77e+00 |5.74e-15                | 2         |-1.62e+00 |-1.07e+00 |2.71e-02                 \n 3         | 1.39e+00 |-1.25e+00 |4.35e-01                | 3         |-1.62e+00 |-2.31e+00 |2.90e-01                 \n                                                          | 4         |-1.06e+00 |-3.77e-01 |1.01e-03                 \nA RMSE of  3.71e-05 was obtained for the the real part of |                                                           \nthe correlation function.                                 |A RMSE of  3.34e-06 was obtained for the the imaginary part\n                                                          |of the correlation function.                               \nThe current fit took  0.860644 seconds.                   |The current fit took  8.516026 seconds.                    \n\n</pre> <p>And we Finally perfom the simulations starting from HEOM</p> In\u00a0[5]: Copied! <pre>tlist = np.linspace(0,120, 1_000)\n\nstart=time()\nsolver = qt.solver.heom.HEOMSolver(H,[(bath1corr,Q)], max_depth=2, options=options)\n# as mentioned below a higher hierarchy is neede, but that would be too slow\nresult = solver.run(rho0, tlist)\nend_heom=time()\n</pre> tlist = np.linspace(0,120, 1_000)  start=time() solver = qt.solver.heom.HEOMSolver(H,[(bath1corr,Q)], max_depth=2, options=options) # as mentioned below a higher hierarchy is neede, but that would be too slow result = solver.run(rho0, tlist) end_heom=time() <pre>10.0%. Run time:   7.71s. Est. time left: 00:00:01:09\n20.0%. Run time:  15.37s. Est. time left: 00:00:01:01\n30.0%. Run time:  22.99s. Est. time left: 00:00:00:53\n40.0%. Run time:  30.62s. Est. time left: 00:00:00:45\n50.1%. Run time:  38.19s. Est. time left: 00:00:00:38\n60.1%. Run time:  45.79s. Est. time left: 00:00:00:30\n70.1%. Run time:  53.35s. Est. time left: 00:00:00:22\n80.1%. Run time:  60.90s. Est. time left: 00:00:00:15\n90.1%. Run time:  68.41s. Est. time left: 00:00:00:07\n100.0%. Run time:  75.89s. Est. time left: 00:00:00:00\nTotal run time:  75.89s\n</pre> <p>Then we continue with cumulant, in the first simulation we use numerical integration while on the second one we use the exponents</p> In\u00a0[6]: Copied! <pre>start2=time()\ncum=csolve(Hsys=H,t=tlist,baths=[bathr],Qs=[Q],cython=False,matsubara=False,ls=False,eps=1e-4)\nresult_cum=cum.evolution(rho0)\nresult_cum2=rotation(result_cum,tlist,Hsys=H)\nend2=time()\n</pre> start2=time() cum=csolve(Hsys=H,t=tlist,baths=[bathr],Qs=[Q],cython=False,matsubara=False,ls=False,eps=1e-4) result_cum=cum.evolution(rho0) result_cum2=rotation(result_cum,tlist,Hsys=H) end2=time() <pre>Calculating Integrals ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 324/324 [01:14&lt;00:00,  4.32it/s]\nCalculating time independent matrices...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 324/324 [00:00&lt;00:00, 8066.02it/s]\nCalculating time dependent generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 324/324 [00:02&lt;00:00, 114.55it/s]\nComputing Exponential of Generators . . . .: 1000it [00:05, 171.19it/s]\n</pre> In\u00a0[7]: Copied! <pre>start3=time()\ncum33=csolve(Hsys=H,t=tlist,baths=[bath1corr],Qs=[Q],cython=False,matsubara=True,ls=True)\nresult_cum33=cum33.evolution(rho0)\nresult_cum3=rotation(result_cum33,tlist,Hsys=H)\nend3=time()\n</pre> start3=time() cum33=csolve(Hsys=H,t=tlist,baths=[bath1corr],Qs=[Q],cython=False,matsubara=True,ls=True) result_cum33=cum33.evolution(rho0) result_cum3=rotation(result_cum33,tlist,Hsys=H) end3=time() <pre>Calculating Integrals ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 324/324 [00:00&lt;00:00, 742.20it/s]\nCalculating time independent matrices...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 324/324 [00:00&lt;00:00, 8139.01it/s]\nCalculating time dependent generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 324/324 [00:05&lt;00:00, 61.66it/s]\nComputing Exponential of Generators . . . .: 1000it [00:05, 182.26it/s]\n</pre> <p>Finally we perform the simulation of GKLS equation</p> In\u00a0[8]: Copied! <pre>start4=time()\nglobal_one=cum.jump_operators(Q) # Global Jump Operators for Bath 1 2-&gt;4\nc_ops=[qt.Qobj((np.sqrt(bathr.power_spectrum(k))*v).data,dims=H.dims) for k, v in global_one.items()]\nresult_lindblad_global2 = qt.mesolve(H, rho0, tlist, c_ops,options={\"rtol\":1e-12,\"atol\":1e-12,\"nsteps\":25_000})\nend4=time()\n</pre> start4=time() global_one=cum.jump_operators(Q) # Global Jump Operators for Bath 1 2-&gt;4 c_ops=[qt.Qobj((np.sqrt(bathr.power_spectrum(k))*v).data,dims=H.dims) for k, v in global_one.items()] result_lindblad_global2 = qt.mesolve(H, rho0, tlist, c_ops,options={\"rtol\":1e-12,\"atol\":1e-12,\"nsteps\":25_000}) end4=time() <p>However, let us take a look at the minimum eigenvalue of the state in time, and norice that HEOM has negative eigenvalues, this is due to a hierarchy that is not high enough and will be fixed if we increase it. To avoid a long simulation, the results will be loaded from an npz, which corresponds to the 4th Hierarchy, the time it took is hardcoded, but you can run it simply by changing the hierarchy above</p> In\u00a0[9]: Copied! <pre>plt.plot(bathr.alpha*tlist,[np.min(i.eigenenergies())for i in result.states])\nplt.plot(bathr.alpha*tlist,[np.min(i.eigenenergies())for i in result_cum3],\"--\")\nplt.plot(bathr.alpha*tlist,[np.min(i.eigenenergies())for i in result_lindblad_global2.states],\"-.\")\nplt.ylabel('min(Eig)')\nplt.xlabel(r'$\\alpha t$')\n</pre> plt.plot(bathr.alpha*tlist,[np.min(i.eigenenergies())for i in result.states]) plt.plot(bathr.alpha*tlist,[np.min(i.eigenenergies())for i in result_cum3],\"--\") plt.plot(bathr.alpha*tlist,[np.min(i.eigenenergies())for i in result_lindblad_global2.states],\"-.\") plt.ylabel('min(Eig)') plt.xlabel(r'$\\alpha t$') Out[9]: <pre>Text(0.5, 0, '$\\\\alpha t$')</pre> <p>We load the results of the simulation with higher hierarchy</p> In\u00a0[10]: Copied! <pre>res=np.load(\"hierarchy_3_kerr.npz\",allow_pickle=True)\nheom=res['heom']\n</pre> res=np.load(\"hierarchy_3_kerr.npz\",allow_pickle=True) heom=res['heom']  <p>We now obtain the plots from the article</p> In\u00a0[11]: Copied! <pre>tr=[qt.fidelity(heom[i],result_cum3[i]) for i in range(len(result_cum))]\ntr2=[qt.fidelity(heom[i],result_lindblad_global2.states[i]) for i in range(len(result_cum))]\n\nplt.plot(bathr.alpha*tlist,tr,label=\"Cumulant\")\nplt.plot(bathr.alpha*tlist,tr2,label=\"GKLS\")\n\nplt.legend()\nplt.xlabel(r\"$\\alpha t$\",fontsize=15)\nplt.ylabel(r\"$\\mathcal{F}_{HEOM}(\\rho)$\",fontsize=15)\n\nplt.show()\nmethods2=[\"Cumulant\"]\nplt.bar(methods2, np.array([end2-start2]),color=\"orange\")\nmethods2=[\"HEOM\",\"Cumulant\"]\nplt.bar(methods2, [11853,end3-start3])\nplt.yscale(\"log\")\nplt.ylabel(r\"$\\log(\\tau)$\",fontsize=15)\n\nplt.show()\n</pre> tr=[qt.fidelity(heom[i],result_cum3[i]) for i in range(len(result_cum))] tr2=[qt.fidelity(heom[i],result_lindblad_global2.states[i]) for i in range(len(result_cum))]  plt.plot(bathr.alpha*tlist,tr,label=\"Cumulant\") plt.plot(bathr.alpha*tlist,tr2,label=\"GKLS\")  plt.legend() plt.xlabel(r\"$\\alpha t$\",fontsize=15) plt.ylabel(r\"$\\mathcal{F}_{HEOM}(\\rho)$\",fontsize=15)  plt.show() methods2=[\"Cumulant\"] plt.bar(methods2, np.array([end2-start2]),color=\"orange\") methods2=[\"HEOM\",\"Cumulant\"] plt.bar(methods2, [11853,end3-start3]) plt.yscale(\"log\") plt.ylabel(r\"$\\log(\\tau)$\",fontsize=15)  plt.show() In\u00a0[12]: Copied! <pre>def plot_expect_with_variance(op_list, op_title, states,\n                                         inset_xlim_start=30, inset_xlim_end=40,\n                                         inset_position_size=[0.65, 0.7, 0.3, 0.25]):\n\n    fig, axes = plt.subplots( len(op_list),1, figsize=(9, 5),sharex=True)\n    scaled_tlist = bathr.alpha * tlist\n\n    for idx, op in enumerate(op_list):\n        main_ax = axes[idx]\n        main_ax.tick_params(labelsize=25)\n        e_op = qt.expect(op, states)\n        v_op = qt.variance(op, states)\n\n        # Main plot\n        main_ax.fill_between(\n            scaled_tlist, e_op - np.sqrt(v_op), e_op + np.sqrt(v_op), color=\"orange\",\n            alpha=0.5\n        )\n        main_ax.plot(scaled_tlist, e_op)\n        main_ax.set_ylabel(op_title[idx],fontsize=25)\n        main_ax.set_xlim(scaled_tlist[0], scaled_tlist[-1])\n    main_ax.set_xlabel(r\"$\\alpha t$\",fontsize=30)\n    plt.tight_layout() # Adjust layout to prevent overlapping titles/labels\n    plt.xlim(0,20)\n    return fig, axes\n</pre> def plot_expect_with_variance(op_list, op_title, states,                                          inset_xlim_start=30, inset_xlim_end=40,                                          inset_position_size=[0.65, 0.7, 0.3, 0.25]):      fig, axes = plt.subplots( len(op_list),1, figsize=(9, 5),sharex=True)     scaled_tlist = bathr.alpha * tlist      for idx, op in enumerate(op_list):         main_ax = axes[idx]         main_ax.tick_params(labelsize=25)         e_op = qt.expect(op, states)         v_op = qt.variance(op, states)          # Main plot         main_ax.fill_between(             scaled_tlist, e_op - np.sqrt(v_op), e_op + np.sqrt(v_op), color=\"orange\",             alpha=0.5         )         main_ax.plot(scaled_tlist, e_op)         main_ax.set_ylabel(op_title[idx],fontsize=25)         main_ax.set_xlim(scaled_tlist[0], scaled_tlist[-1])     main_ax.set_xlabel(r\"$\\alpha t$\",fontsize=30)     plt.tight_layout() # Adjust layout to prevent overlapping titles/labels     plt.xlim(0,20)     return fig, axes In\u00a0[13]: Copied! <pre>fig1=plot_expect_with_variance([n, x, p], [r\"$\\langle N \\rangle$\", r\"$\\langle X \\rangle$\", r\"$\\langle P \\rangle$\"], result.states)\n</pre> fig1=plot_expect_with_variance([n, x, p], [r\"$\\langle N \\rangle$\", r\"$\\langle X \\rangle$\", r\"$\\langle P \\rangle$\"], result.states)"},{"location":"kerr_example/#example-4-a-kerr-nonlinearity-in-an-ohmic-enviroment","title":"Example 4:  A Kerr nonlinearity in an Ohmic enviroment\u00b6","text":"<p>This example provides the necessary code to reproduce the calculations from example 3 in 2, where the Hamiltonian is given by</p> <p>\\begin{align}      H &amp;=\\underbrace{\\omega_{0} a^{\\dagger}a+\\frac{\\chi}{2} a^{\\dagger}a^{\\dagger}aa}_{H_S}+ \\underbrace{\\sum_{k} w_{k} a_{k}^{\\dagger} a_{k}}_{H_B} + \\underbrace{(a+a^{\\dagger})\\sum_{k} g_k (a_{k}+a_{k}^{\\dagger})}_{H_I}. \\end{align}</p> <p>We first begin by importing the necessary packages</p>"},{"location":"spectral_density_data/","title":"Spectral density data","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\ntable1_omega_k = np.array([\n        46, 68, 117, 167, 180, 191, 202, 243, 263, 284,\n        291, 327, 366, 385, 404, 423, 440, 481, 541, 568,\n        582, 597, 630, 638, 665, 684, 713, 726, 731, 750,\n        761, 770, 795, 821, 856, 891, 900, 924, 929, 946,\n        966, 984, 1004, 1037, 1058, 1094, 1104, 1123, 1130, 1162,\n        1175, 1181, 1201, 1220, 1283, 1292, 1348, 1367, 1386, 1431,\n        1503, 1545\n    ], dtype=float)\n</pre> import numpy as np table1_omega_k = np.array([         46, 68, 117, 167, 180, 191, 202, 243, 263, 284,         291, 327, 366, 385, 404, 423, 440, 481, 541, 568,         582, 597, 630, 638, 665, 684, 713, 726, 731, 750,         761, 770, 795, 821, 856, 891, 900, 924, 929, 946,         966, 984, 1004, 1037, 1058, 1094, 1104, 1123, 1130, 1162,         1175, 1181, 1201, 1220, 1283, 1292, 1348, 1367, 1386, 1431,         1503, 1545     ], dtype=float) In\u00a0[\u00a0]: Copied! <pre># Huang-Rhys factors s_k\ntable1_s_k = np.array([\n    0.011, 0.011, 0.009, 0.009, 0.010, 0.011, 0.011, 0.012, 0.003, 0.008,\n    0.008, 0.003, 0.006, 0.002, 0.002, 0.002, 0.001, 0.002, 0.004, 0.007,\n    0.004, 0.004, 0.003, 0.006, 0.004, 0.003, 0.007, 0.010, 0.005, 0.004,\n    0.009, 0.018, 0.007, 0.006, 0.007, 0.003, 0.004, 0.001, 0.001, 0.002,\n    0.002, 0.003, 0.001, 0.002, 0.002, 0.001, 0.001, 0.003, 0.003, 0.009,\n    0.007, 0.010, 0.003, 0.005, 0.002, 0.004, 0.007, 0.002, 0.004, 0.002,\n    0.003, 0.003\n], dtype=float)\ndef Jh(omega, table_omega_k_vals, table_s_k_vals, gamma_k_val=5.0):\n    omega_arr = np.asarray(omega, dtype=float)*100\n    \n    total_j_h_omega = np.zeros_like(omega_arr)\n\n    positive_omega_mask = omega_arr &gt; 0\n    \n    if not np.any(positive_omega_mask):\n        if isinstance(omega, (int, float)):\n            return 0.0\n        else:\n            return total_j_h_omega # All zeros\n\n    # Process only positive omega values\n    omega_pos = omega_arr[positive_omega_mask]\n    \n    # Accumulator for J_h for positive omegas\n    j_h_omega_pos_accumulator = np.zeros_like(omega_pos)\n\n    gamma_k_sq = gamma_k_val**2\n\n    # Iterate over each mode k from Table I\n    for omega_k, s_k in zip(table_omega_k_vals, table_s_k_vals):\n        if omega_k &lt;= 0: # Should not happen based on Table I, but good check\n            continue\n\n        omega_k_sq = omega_k**2\n        \n        numerator_k = (4 * omega_k * s_k * gamma_k_val * (omega_k_sq + gamma_k_sq) * omega_pos)\n\n        # Denominator parts for mode k\n        term_denom1 = (omega_pos + omega_k)**2 + gamma_k_sq\n        term_denom2 = (omega_pos - omega_k)**2 + gamma_k_sq\n        denominator_k = np.pi * term_denom1 * term_denom2\n        \n        # Add contribution of mode k\n        j_h_omega_pos_accumulator += numerator_k / denominator_k\n        \n    # Assign calculated positive values to the corresponding positions\n    total_j_h_omega[positive_omega_mask] = j_h_omega_pos_accumulator\n\n    # If the original input was a scalar, return a scalar\n    if isinstance(omega, (int, float)):\n        return total_j_h_omega.item()\n    else:\n        return total_j_h_omega\n</pre> # Huang-Rhys factors s_k table1_s_k = np.array([     0.011, 0.011, 0.009, 0.009, 0.010, 0.011, 0.011, 0.012, 0.003, 0.008,     0.008, 0.003, 0.006, 0.002, 0.002, 0.002, 0.001, 0.002, 0.004, 0.007,     0.004, 0.004, 0.003, 0.006, 0.004, 0.003, 0.007, 0.010, 0.005, 0.004,     0.009, 0.018, 0.007, 0.006, 0.007, 0.003, 0.004, 0.001, 0.001, 0.002,     0.002, 0.003, 0.001, 0.002, 0.002, 0.001, 0.001, 0.003, 0.003, 0.009,     0.007, 0.010, 0.003, 0.005, 0.002, 0.004, 0.007, 0.002, 0.004, 0.002,     0.003, 0.003 ], dtype=float) def Jh(omega, table_omega_k_vals, table_s_k_vals, gamma_k_val=5.0):     omega_arr = np.asarray(omega, dtype=float)*100          total_j_h_omega = np.zeros_like(omega_arr)      positive_omega_mask = omega_arr &gt; 0          if not np.any(positive_omega_mask):         if isinstance(omega, (int, float)):             return 0.0         else:             return total_j_h_omega # All zeros      # Process only positive omega values     omega_pos = omega_arr[positive_omega_mask]          # Accumulator for J_h for positive omegas     j_h_omega_pos_accumulator = np.zeros_like(omega_pos)      gamma_k_sq = gamma_k_val**2      # Iterate over each mode k from Table I     for omega_k, s_k in zip(table_omega_k_vals, table_s_k_vals):         if omega_k &lt;= 0: # Should not happen based on Table I, but good check             continue          omega_k_sq = omega_k**2                  numerator_k = (4 * omega_k * s_k * gamma_k_val * (omega_k_sq + gamma_k_sq) * omega_pos)          # Denominator parts for mode k         term_denom1 = (omega_pos + omega_k)**2 + gamma_k_sq         term_denom2 = (omega_pos - omega_k)**2 + gamma_k_sq         denominator_k = np.pi * term_denom1 * term_denom2                  # Add contribution of mode k         j_h_omega_pos_accumulator += numerator_k / denominator_k              # Assign calculated positive values to the corresponding positions     total_j_h_omega[positive_omega_mask] = j_h_omega_pos_accumulator      # If the original input was a scalar, return a scalar     if isinstance(omega, (int, float)):         return total_j_h_omega.item()     else:         return total_j_h_omega In\u00a0[\u00a0]: Copied! <pre>def Jar(omega):\n\n    omega_arr = np.asarray(omega, dtype=float)*100\n    j_ar_omega = np.zeros_like(omega_arr)\n\n    # Constants from the paper\n    S = 0.29\n    s1 = 0.8\n    s2 = 0.5\n    omega1_val = 0.069  # meV\n    omega2_val = 0.24   # meV\n\n    # Pre-calculated constant values\n    s1_plus_s2 = s1 + s2  # 1.3\n    seven_factorial_times_2 = 10080.0  # 7! * 2 = 5040 * 2\n\n    # Calculate the main coefficient\n    main_coefficient = S / s1_plus_s2\n\n    \n    positive_omega_mask = omega_arr &gt; 0\n    \n    if np.any(positive_omega_mask):\n        omega_pos = omega_arr[positive_omega_mask]\n\n        # Term 1 components\n        term1_s_factor = s1\n        term1_omega_factor_denom = (omega1_val**4)\n        term1_denom = seven_factorial_times_2 * term1_omega_factor_denom\n        term1_exp_arg = np.sqrt(omega_pos / omega1_val) \n        term1 = (term1_s_factor / term1_denom) * (omega_pos**5) * np.exp(-term1_exp_arg)\n\n        # Term 2 components\n        term2_s_factor = s2\n        term2_omega_factor_denom = (omega2_val**4)\n        term2_denom = seven_factorial_times_2 * term2_omega_factor_denom\n        term2_exp_arg = np.sqrt(omega_pos / omega2_val)\n        term2 = (term2_s_factor / term2_denom) * (omega_pos**5) * np.exp(-term2_exp_arg)\n\n        # Combine terms for positive omega values\n        j_ar_omega_positive_values = main_coefficient * (term1 + term2)\n        \n        # Assign calculated values to the corresponding positions in the result array\n        j_ar_omega[positive_omega_mask] = j_ar_omega_positive_values\n\n    # If the original input was a scalar, return a scalar\n    if isinstance(omega, (int, float)):\n        return j_ar_omega.item()\n    else:\n        return j_ar_omega \n</pre> def Jar(omega):      omega_arr = np.asarray(omega, dtype=float)*100     j_ar_omega = np.zeros_like(omega_arr)      # Constants from the paper     S = 0.29     s1 = 0.8     s2 = 0.5     omega1_val = 0.069  # meV     omega2_val = 0.24   # meV      # Pre-calculated constant values     s1_plus_s2 = s1 + s2  # 1.3     seven_factorial_times_2 = 10080.0  # 7! * 2 = 5040 * 2      # Calculate the main coefficient     main_coefficient = S / s1_plus_s2           positive_omega_mask = omega_arr &gt; 0          if np.any(positive_omega_mask):         omega_pos = omega_arr[positive_omega_mask]          # Term 1 components         term1_s_factor = s1         term1_omega_factor_denom = (omega1_val**4)         term1_denom = seven_factorial_times_2 * term1_omega_factor_denom         term1_exp_arg = np.sqrt(omega_pos / omega1_val)          term1 = (term1_s_factor / term1_denom) * (omega_pos**5) * np.exp(-term1_exp_arg)          # Term 2 components         term2_s_factor = s2         term2_omega_factor_denom = (omega2_val**4)         term2_denom = seven_factorial_times_2 * term2_omega_factor_denom         term2_exp_arg = np.sqrt(omega_pos / omega2_val)         term2 = (term2_s_factor / term2_denom) * (omega_pos**5) * np.exp(-term2_exp_arg)          # Combine terms for positive omega values         j_ar_omega_positive_values = main_coefficient * (term1 + term2)                  # Assign calculated values to the corresponding positions in the result array         j_ar_omega[positive_omega_mask] = j_ar_omega_positive_values      # If the original input was a scalar, return a scalar     if isinstance(omega, (int, float)):         return j_ar_omega.item()     else:         return j_ar_omega  In\u00a0[\u00a0]: Copied! <pre>def spectral_density(w):\n    return (Jh(w,table1_omega_k,table1_s_k)+Jar(w))/15000\n</pre> def spectral_density(w):     return (Jh(w,table1_omega_k,table1_s_k)+Jar(w))/15000"},{"location":"transport_example/","title":"Example 3: Heat transport in a two qubit machine with underdamped enviroments","text":"In\u00a0[1]: Copied! <pre>import qutip as qt \nimport numpy as np\nfrom qutip.core.environment import UnderDampedEnvironment\nfrom nmm.redfield import redfield\nfrom nmm import csolve\nfrom scipy import linalg\nfrom qutip.solver.heom import HEOMSolver\nfrom qutip.solver.heom import BosonicBath,HEOMSolver,BathExponent\nfrom time import time\nimport matplotlib.pyplot as plt\n</pre> import qutip as qt  import numpy as np from qutip.core.environment import UnderDampedEnvironment from nmm.redfield import redfield from nmm import csolve from scipy import linalg from qutip.solver.heom import HEOMSolver from qutip.solver.heom import BosonicBath,HEOMSolver,BathExponent from time import time import matplotlib.pyplot as plt  <p>This next block of code defines how to compute heat currents, part of it is directly adapted from the QuTiP tutorial about heat transport in HEOM</p> In\u00a0[2]: Copied! <pre>def bath_heat_current(bath_tag, ado_state, hamiltonian, coupling_op):\n    \"\"\"\n    Bath heat current from the system into the heat bath with the given tag.\n\n    Parameters\n    ----------\n    bath_tag : str, tuple or any other object\n        Tag of the heat bath corresponding to the current of interest.\n\n    ado_state : HierarchyADOsState\n        Current state of the system and the environment (encoded in the ADOs).\n\n    hamiltonian : Qobj\n        System Hamiltonian at the current time.\n\n    coupling_op : Qobj\n        System coupling operator at the current time.\n\n    delta : float\n        The prefactor of the \\\\delta(t) term in the correlation function (the\n        Ishizaki-Tanimura terminator).\n    Taken from the Qutip tutorials\n    \"\"\"\n    l1_labels = ado_state.filter(level=1, tags=[bath_tag])\n    a_op = 1j * (hamiltonian * coupling_op - coupling_op * hamiltonian)\n\n    result = 0\n    cI0 = 0  # imaginary part of bath auto-correlation function (t=0)\n    for label in l1_labels:\n        [exp] = ado_state.exps(label)\n        result += exp.vk * (coupling_op * ado_state.extract(label)).tr()\n\n        if exp.type == BathExponent.types['I']:\n            cI0 += exp.ck\n        elif exp.type == BathExponent.types['RI']:\n            cI0 += exp.ck2\n\n    result -= 2 * cI0 * (coupling_op * coupling_op * ado_state.rho).tr()\n    return result\n\n\ndef system_heat_current(\n    bath_tag, ado_state, hamiltonian, coupling_op\n):\n    \"\"\"\n    System heat current from the system into the heat bath with the given tag.\n\n    Parameters\n    ----------\n    bath_tag : str, tuple or any other object\n        Tag of the heat bath corresponding to the current of interest.\n\n    ado_state : HierarchyADOsState\n        Current state of the system and the environment (encoded in the ADOs).\n\n    hamiltonian : Qobj\n        System Hamiltonian at the current time.\n\n    coupling_op : Qobj\n        System coupling operator at the current time.\n\n    delta : float\n        The prefactor of the \\\\delta(t) term in the correlation function (the\n        Ishizaki-Tanimura terminator).\n    Taken from the Qutip tutorials\n    \"\"\"\n    l1_labels = ado_state.filter(level=1, tags=[bath_tag])\n    a_op = 1j * (hamiltonian * coupling_op - coupling_op * hamiltonian)\n\n    result = 0\n    for label in l1_labels:\n        result += (a_op * ado_state.extract(label)).tr()\n\n\n    return result\ndef rotation(data, t, Hsys):\n    try:\n        rotated = [\n            (-1j * Hsys * t[i]).expm()\n            * data[i]\n            * (1j * Hsys * t[i]).expm()\n            for i in range(len(t))\n        ]\n    except:\n        rotated = [\n            (-1j * Hsys * t[i]).expm()\n            * qt.Qobj(data[i],dims=Hsys.dims)\n            * (1j * Hsys * t[i]).expm()\n            for i in range(len(t))\n        ]\n        \n    return rotated\ndef D(cops,state):\n    return sum([i*state*i.dag() - (i.dag()*i*state+ state*i.dag()*i)/2 for i in cops])\ndef master_currents_nm(Hsys,Q1,tlist,bath1corr,result_cum,result_red,ls=False):\n    rdj1=redfield(Hsys=Hsys,baths=[bath1corr],t=tlist,Qs=[Q1],eps=1e-8,matsubara=True,ls=ls,picture=\"S\")\n    rdj1.prepare_interpolated_generators()\n    rdj11=[rdj1.interpolated_generator(i) for i in tlist]\n    j1cum=[((rdj11[i]@result_cum[i].full().flatten()).reshape(4,4)@Hsys.full()).trace()for i in range(len(tlist))]\n    j1red=[((rdj11[i]@result_red[i].flatten()).reshape(4,4)@Hsys.full()).trace()for i in range(len(tlist))]\n    cum1=csolve(Hsys=Hsys,t=tlist,baths=[bath1corr],Qs=[Q1],cython=False,matsubara=True,ls=ls)\n    cum1.generator()\n    gene=np.array([(i).expm().full() for i in cum1.generators])\n    gene2=np.array([(-i).expm().full() for i in cum1.generators])\n    dK_dt = np.gradient(gene, tlist, axis=0)\n    dK_dt[0]=gene[0]*0\n    gene_diff= [dK_dt[i]@gene2[i] for i in range(len(tlist))]\n    j1cum2=[((gene_diff[i]@result_cum[i].full().flatten()).reshape(4,4)@Hsys.full()).trace()for i in range(len(tlist))]\n    return j1cum,j1red,j1cum2 #j1cum and j2cum denote both ways to compute the cumulant current as oulined in 2\n    # Notice that 2 suffers from problems with numerical differentiation which we hope to get rid of using automatic \n    # differentiation soon\ndef master_currents(Hsys,c_ops,c_ops_global,result_global,result_local):  \n    j1s=np.array([(Hsys*D(c_ops_global,i)).tr() for i in result_global.states])\n    j1s_local=np.array([(Hsys*D(c_ops,i)).tr() for i in result_local.states])\n    return j1s_local,j1s\n</pre> def bath_heat_current(bath_tag, ado_state, hamiltonian, coupling_op):     \"\"\"     Bath heat current from the system into the heat bath with the given tag.      Parameters     ----------     bath_tag : str, tuple or any other object         Tag of the heat bath corresponding to the current of interest.      ado_state : HierarchyADOsState         Current state of the system and the environment (encoded in the ADOs).      hamiltonian : Qobj         System Hamiltonian at the current time.      coupling_op : Qobj         System coupling operator at the current time.      delta : float         The prefactor of the \\\\delta(t) term in the correlation function (the         Ishizaki-Tanimura terminator).     Taken from the Qutip tutorials     \"\"\"     l1_labels = ado_state.filter(level=1, tags=[bath_tag])     a_op = 1j * (hamiltonian * coupling_op - coupling_op * hamiltonian)      result = 0     cI0 = 0  # imaginary part of bath auto-correlation function (t=0)     for label in l1_labels:         [exp] = ado_state.exps(label)         result += exp.vk * (coupling_op * ado_state.extract(label)).tr()          if exp.type == BathExponent.types['I']:             cI0 += exp.ck         elif exp.type == BathExponent.types['RI']:             cI0 += exp.ck2      result -= 2 * cI0 * (coupling_op * coupling_op * ado_state.rho).tr()     return result   def system_heat_current(     bath_tag, ado_state, hamiltonian, coupling_op ):     \"\"\"     System heat current from the system into the heat bath with the given tag.      Parameters     ----------     bath_tag : str, tuple or any other object         Tag of the heat bath corresponding to the current of interest.      ado_state : HierarchyADOsState         Current state of the system and the environment (encoded in the ADOs).      hamiltonian : Qobj         System Hamiltonian at the current time.      coupling_op : Qobj         System coupling operator at the current time.      delta : float         The prefactor of the \\\\delta(t) term in the correlation function (the         Ishizaki-Tanimura terminator).     Taken from the Qutip tutorials     \"\"\"     l1_labels = ado_state.filter(level=1, tags=[bath_tag])     a_op = 1j * (hamiltonian * coupling_op - coupling_op * hamiltonian)      result = 0     for label in l1_labels:         result += (a_op * ado_state.extract(label)).tr()       return result def rotation(data, t, Hsys):     try:         rotated = [             (-1j * Hsys * t[i]).expm()             * data[i]             * (1j * Hsys * t[i]).expm()             for i in range(len(t))         ]     except:         rotated = [             (-1j * Hsys * t[i]).expm()             * qt.Qobj(data[i],dims=Hsys.dims)             * (1j * Hsys * t[i]).expm()             for i in range(len(t))         ]              return rotated def D(cops,state):     return sum([i*state*i.dag() - (i.dag()*i*state+ state*i.dag()*i)/2 for i in cops]) def master_currents_nm(Hsys,Q1,tlist,bath1corr,result_cum,result_red,ls=False):     rdj1=redfield(Hsys=Hsys,baths=[bath1corr],t=tlist,Qs=[Q1],eps=1e-8,matsubara=True,ls=ls,picture=\"S\")     rdj1.prepare_interpolated_generators()     rdj11=[rdj1.interpolated_generator(i) for i in tlist]     j1cum=[((rdj11[i]@result_cum[i].full().flatten()).reshape(4,4)@Hsys.full()).trace()for i in range(len(tlist))]     j1red=[((rdj11[i]@result_red[i].flatten()).reshape(4,4)@Hsys.full()).trace()for i in range(len(tlist))]     cum1=csolve(Hsys=Hsys,t=tlist,baths=[bath1corr],Qs=[Q1],cython=False,matsubara=True,ls=ls)     cum1.generator()     gene=np.array([(i).expm().full() for i in cum1.generators])     gene2=np.array([(-i).expm().full() for i in cum1.generators])     dK_dt = np.gradient(gene, tlist, axis=0)     dK_dt[0]=gene[0]*0     gene_diff= [dK_dt[i]@gene2[i] for i in range(len(tlist))]     j1cum2=[((gene_diff[i]@result_cum[i].full().flatten()).reshape(4,4)@Hsys.full()).trace()for i in range(len(tlist))]     return j1cum,j1red,j1cum2 #j1cum and j2cum denote both ways to compute the cumulant current as oulined in 2     # Notice that 2 suffers from problems with numerical differentiation which we hope to get rid of using automatic      # differentiation soon def master_currents(Hsys,c_ops,c_ops_global,result_global,result_local):       j1s=np.array([(Hsys*D(c_ops_global,i)).tr() for i in result_global.states])     j1s_local=np.array([(Hsys*D(c_ops,i)).tr() for i in result_local.states])     return j1s_local,j1s  <p>We now specify the parameters for the simulation as well as the initial state</p> In\u00a0[3]: Copied! <pre>w=1\nDelta=1\nlam=0.05\nT1=0.01\nT2=2\ng=0.5\nH1   = w / 2 * qt.tensor(qt.sigmaz(), qt.identity(2))\nH2   = (w) / 2 * qt.tensor(qt.identity(2), qt.sigmaz())\nH1T   = Delta / 2 * qt.tensor(qt.sigmax(), qt.identity(2))\nH12  = g * qt.tensor(qt.sigmax(), qt.sigmax())\nHsys = H1 + H2 + H12 +H1T \nwc1 = 1*w\nwc2 = 1*w\nw0=2*w\n# Coupling operators\nQ1 = qt.tensor(qt.sigmax(), qt.identity(2))\nQ2 = qt.tensor(qt.identity(2), qt.sigmax())\n\n# qubit-qubit and qubit-bath coupling strengths\nlam1 = lam*np.pi*w #bath1\nlam2 = lam*np.pi*w #bath2\n# choose arbitrary initial state\nrho0 =qt.Qobj([[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]])\nrho0.dims=Hsys.dims\n# simulation time span\nt=np.linspace(0,80,5000)\nbath1=UnderDampedEnvironment(T=T1,lam=lam1,gamma=wc1,w0=w0)\nbath1corr,finfo1=bath1.approx_by_cf_fit(t,tag=\"bath 1\",Ni_max=1,Nr_max=4,maxfev=1e8,target_rmse=None)\nprint(finfo1['summary'])\n\nbath2=UnderDampedEnvironment(T=T2,lam=lam2,gamma=wc2,w0=w0)\nbath2corr,finfo2=bath2.approx_by_cf_fit(t,tag=\"bath 2\",Ni_max=1,Nr_max=4,maxfev=1e8,target_rmse=None)\nprint(finfo2['summary'])\n\noptions = {'nsteps':15000, 'store_states':True,'store_ados':True,'rtol':1e-12,'atol':1e-12}\n</pre> w=1 Delta=1 lam=0.05 T1=0.01 T2=2 g=0.5 H1   = w / 2 * qt.tensor(qt.sigmaz(), qt.identity(2)) H2   = (w) / 2 * qt.tensor(qt.identity(2), qt.sigmaz()) H1T   = Delta / 2 * qt.tensor(qt.sigmax(), qt.identity(2)) H12  = g * qt.tensor(qt.sigmax(), qt.sigmax()) Hsys = H1 + H2 + H12 +H1T  wc1 = 1*w wc2 = 1*w w0=2*w # Coupling operators Q1 = qt.tensor(qt.sigmax(), qt.identity(2)) Q2 = qt.tensor(qt.identity(2), qt.sigmax())  # qubit-qubit and qubit-bath coupling strengths lam1 = lam*np.pi*w #bath1 lam2 = lam*np.pi*w #bath2 # choose arbitrary initial state rho0 =qt.Qobj([[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]) rho0.dims=Hsys.dims # simulation time span t=np.linspace(0,80,5000) bath1=UnderDampedEnvironment(T=T1,lam=lam1,gamma=wc1,w0=w0) bath1corr,finfo1=bath1.approx_by_cf_fit(t,tag=\"bath 1\",Ni_max=1,Nr_max=4,maxfev=1e8,target_rmse=None) print(finfo1['summary'])  bath2=UnderDampedEnvironment(T=T2,lam=lam2,gamma=wc2,w0=w0) bath2corr,finfo2=bath2.approx_by_cf_fit(t,tag=\"bath 2\",Ni_max=1,Nr_max=4,maxfev=1e8,target_rmse=None) print(finfo2['summary'])  options = {'nsteps':15000, 'store_states':True,'store_ados':True,'rtol':1e-12,'atol':1e-12}  <pre>/home/Gerardo/qutip_new/qutip/core/environment.py:753: FutureWarning: The API has changed. Please use approximate(\"cf\", ...) instead of approx_by_cf_fit(...).\n  warnings.warn('The API has changed. Please use approximate(\"cf\", ...)'\n/home/Gerardo/qutip_new/qutip/utilities.py:56: RuntimeWarning: overflow encountered in exp\n  result[non_zero] = 1 / (np.exp(w[non_zero] / w_th) - 1)\n</pre> <pre>Correlation function fit:\n\nResult of fitting the real part of                        |Result of fitting the imaginary part                       \nthe correlation function with 4 terms:                    |of the correlation function with 1 terms:                  \n                                                          |                                                           \n Parameters|   ckr    |   vkr    |  vki                   | Parameters|   ckr    |   vkr    |  vki                    \n 1         |-4.19e-05 |-2.11e-01 |2.25e-06                | 1         |-6.37e-03 |-5.00e-01 |1.94e+00                 \n 2         |-4.94e-04 |-1.05e+00 |1.89e-05                |                                                           \n 3         |-4.51e-04 |-4.67e+00 |2.71e-03                |A RMSE of  4.58e-07 was obtained for the the imaginary part\n 4         | 6.34e-03 |-4.99e-01 |1.94e+00                |of the correlation function.                               \n                                                          |                                                           \nA RMSE of  7.30e-07 was obtained for the the real part of |                                                           \nthe correlation function.                                 |                                                           \nThe current fit took  1.004905 seconds.                   |The current fit took  0.032430 seconds.                    \n\nCorrelation function fit:\n\nResult of fitting the real part of                        |Result of fitting the imaginary part                       \nthe correlation function with 4 terms:                    |of the correlation function with 1 terms:                  \n                                                          |                                                           \n Parameters|   ckr    |   vkr    |  vki                   | Parameters|   ckr    |   vkr    |  vki                    \n 1         | 8.75e-02 |-1.40e+00 |1.10e+00                | 1         |-6.37e-03 |-5.00e-01 |1.94e+00                 \n 2         | 4.31e-03 |-6.22e-01 |1.58e+00                |                                                           \n 3         |-8.99e-02 |-1.44e+00 |1.17e+00                |A RMSE of  4.58e-07 was obtained for the the imaginary part\n 4         | 1.15e-02 |-4.64e-01 |1.92e+00                |of the correlation function.                               \n                                                          |                                                           \nA RMSE of  2.60e-06 was obtained for the the real part of |                                                           \nthe correlation function.                                 |                                                           \nThe current fit took  5.497878 seconds.                   |The current fit took  0.023096 seconds.                    \n\n</pre> <p>Similarly to the other examples we now perform each of the simulations with the different methods</p> In\u00a0[4]: Copied! <pre>options = {'nsteps':15000, 'store_states':True,'store_ados':True,'rtol':1e-8,'atol':1e-8,\"method\":\"bdf\"}\ntlist = np.linspace(0,100/bath1.lam, 5000)\nstart=time()\nsolver = HEOMSolver(Hsys,[(bath1corr,Q1),(bath2corr,Q2)], max_depth=4, options=options) # this is slow\nresult = solver.run(rho0, tlist)\nend_heom=time()\n</pre> options = {'nsteps':15000, 'store_states':True,'store_ados':True,'rtol':1e-8,'atol':1e-8,\"method\":\"bdf\"} tlist = np.linspace(0,100/bath1.lam, 5000) start=time() solver = HEOMSolver(Hsys,[(bath1corr,Q1),(bath2corr,Q2)], max_depth=4, options=options) # this is slow result = solver.run(rho0, tlist) end_heom=time() <pre>10.0%. Run time:  49.22s. Est. time left: 00:00:07:22\n20.0%. Run time:  97.13s. Est. time left: 00:00:06:28\n30.0%. Run time: 144.24s. Est. time left: 00:00:05:36\n40.0%. Run time: 188.27s. Est. time left: 00:00:04:42\n50.0%. Run time: 229.63s. Est. time left: 00:00:03:49\n60.0%. Run time: 274.37s. Est. time left: 00:00:03:02\n70.0%. Run time: 317.54s. Est. time left: 00:00:02:15\n80.0%. Run time: 357.86s. Est. time left: 00:00:01:29\n90.0%. Run time: 398.56s. Est. time left: 00:00:00:44\n100.0%. Run time: 438.48s. Est. time left: 00:00:00:00\nTotal run time: 438.49s\n</pre> In\u00a0[5]: Copied! <pre>start2=time()\ncum=csolve(Hsys=Hsys,t=tlist,baths=[bath1corr,bath2corr],Qs=[Q1,Q2],cython=False,matsubara=True,ls=False)\nresult_cum=cum.evolution(rho0)\nresult_cum2=rotation(result_cum,tlist,Hsys=Hsys)\nend2=time()\n</pre> start2=time() cum=csolve(Hsys=Hsys,t=tlist,baths=[bath1corr,bath2corr],Qs=[Q1,Q2],cython=False,matsubara=True,ls=False) result_cum=cum.evolution(rho0) result_cum2=rotation(result_cum,tlist,Hsys=Hsys) end2=time() <pre>Calculating Integrals ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81/81 [00:00&lt;00:00, 230.77it/s]\nCalculating time independent matrices...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81/81 [00:00&lt;00:00, 6009.99it/s]\nCalculating time dependent generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81/81 [00:04&lt;00:00, 17.92it/s]\nCalculating Integrals ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:00&lt;00:00, 251.46it/s]\nCalculating time independent matrices...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:00&lt;00:00, 5700.95it/s]\nCalculating time dependent generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:01&lt;00:00, 20.23it/s]\nComputing Exponential of Generators . . . .: 5000it [00:01, 2700.90it/s]\n</pre> In\u00a0[6]: Copied! <pre>start3=time()\ncum_int=csolve(Hsys=Hsys,t=tlist,baths=[bath1,bath2],Qs=[Q1,Q2],cython=False,matsubara=False,ls=False)\nresult_cum_int=cum_int.evolution(rho0)\nresult_cum2_int=rotation(result_cum_int,tlist,Hsys=Hsys)\nend3=time()\n</pre> start3=time() cum_int=csolve(Hsys=Hsys,t=tlist,baths=[bath1,bath2],Qs=[Q1,Q2],cython=False,matsubara=False,ls=False) result_cum_int=cum_int.evolution(rho0) result_cum2_int=rotation(result_cum_int,tlist,Hsys=Hsys) end3=time() <pre>Calculating Integrals ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81/81 [01:18&lt;00:00,  1.04it/s]\nCalculating time independent matrices...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81/81 [00:00&lt;00:00, 5886.59it/s]\nCalculating time dependent generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81/81 [00:04&lt;00:00, 17.58it/s]\nCalculating Integrals ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:34&lt;00:00,  1.38s/it]\nCalculating time independent matrices...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:00&lt;00:00, 5594.79it/s]\nCalculating time dependent generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:01&lt;00:00, 18.73it/s]\nComputing Exponential of Generators . . . .: 5000it [00:01, 2737.73it/s]\n</pre> In\u00a0[7]: Copied! <pre>start4=time()\ncum_ls=csolve(Hsys=Hsys,t=tlist,baths=[bath1corr,bath2corr],Qs=[Q1,Q2],cython=False,matsubara=True,ls=True)\nresult_cum_ls=cum.evolution(rho0)\nresult_cum2_ls=rotation(result_cum,tlist,Hsys=Hsys)\nend4=time()\n</pre> start4=time() cum_ls=csolve(Hsys=Hsys,t=tlist,baths=[bath1corr,bath2corr],Qs=[Q1,Q2],cython=False,matsubara=True,ls=True) result_cum_ls=cum.evolution(rho0) result_cum2_ls=rotation(result_cum,tlist,Hsys=Hsys) end4=time() <pre>Calculating Integrals ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81/81 [00:00&lt;00:00, 239.19it/s]\nCalculating time independent matrices...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81/81 [00:00&lt;00:00, 5905.31it/s]\nCalculating time dependent generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81/81 [00:04&lt;00:00, 17.67it/s]\nCalculating Integrals ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:00&lt;00:00, 251.51it/s]\nCalculating time independent matrices...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:00&lt;00:00, 5828.66it/s]\nCalculating time dependent generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:01&lt;00:00, 20.11it/s]\nComputing Exponential of Generators . . . .: 5000it [00:01, 2627.71it/s]\n</pre> In\u00a0[8]: Copied! <pre>start5=time()\nrd2=redfield(Hsys=Hsys,baths=[bath1corr,bath2corr],t=tlist,Qs=[Q1,Q2],eps=1e-8,matsubara=True,ls=False,picture=\"S\")\nresult_red=rd2.evolution(rho0,method=\"BDF\")\nend5=time()\n</pre> start5=time() rd2=redfield(Hsys=Hsys,baths=[bath1corr,bath2corr],t=tlist,Qs=[Q1,Q2],eps=1e-8,matsubara=True,ls=False,picture=\"S\") result_red=rd2.evolution(rho0,method=\"BDF\") end5=time() <pre>Started integration and Generator Calculations\nFinished integration and Generator Calculations\nComputation Time:6.34388542175293\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nStarted interpolation\nFinished interpolation\nComputation Time:0.020324230194091797\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nStarted Solving the differential equation\nFinished Solving the differential equation\nComputation Time:34.58197641372681\n</pre> In\u00a0[9]: Copied! <pre>start6=time()\nrd2_ls=redfield(Hsys=Hsys,baths=[bath1corr,bath2corr],t=tlist,Qs=[Q1,Q2],eps=1e-8,matsubara=True,ls=True,picture=\"S\")\nresult_red_ls=rd2_ls.evolution(rho0,method=\"BDF\")\nend6=time()\n</pre> start6=time() rd2_ls=redfield(Hsys=Hsys,baths=[bath1corr,bath2corr],t=tlist,Qs=[Q1,Q2],eps=1e-8,matsubara=True,ls=True,picture=\"S\") result_red_ls=rd2_ls.evolution(rho0,method=\"BDF\") end6=time() <pre>Started integration and Generator Calculations\nFinished integration and Generator Calculations\nComputation Time:11.740429639816284\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nStarted interpolation\nFinished interpolation\nComputation Time:0.020132064819335938\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nStarted Solving the differential equation\nFinished Solving the differential equation\nComputation Time:34.497650384902954\n</pre> In\u00a0[10]: Copied! <pre>start7=time()\nrd2_ls=redfield(Hsys=Hsys,baths=[bath1,bath2],t=tlist,Qs=[Q1,Q2],eps=1e-2,matsubara=False,ls=False,picture=\"S\")\nresult_red_ls_int=rd2_ls.evolution(rho0,method=\"BDF\") # this is slow, Feel free to comment this and skip this calculation\nend7=time()\n</pre> start7=time() rd2_ls=redfield(Hsys=Hsys,baths=[bath1,bath2],t=tlist,Qs=[Q1,Q2],eps=1e-2,matsubara=False,ls=False,picture=\"S\") result_red_ls_int=rd2_ls.evolution(rho0,method=\"BDF\") # this is slow, Feel free to comment this and skip this calculation end7=time() <pre>Started integration and Generator Calculations\n</pre> <pre>/home/Gerardo/NonMarkovianMethods/nmm/redfield/redfield.py:85: RuntimeWarning: overflow encountered in exp\n  return 1 / (np.exp(w / bath.T)-1)\n</pre> <pre>Finished integration and Generator Calculations\nComputation Time:1215.9020819664001\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nStarted interpolation\nFinished interpolation\nComputation Time:0.019315242767333984\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nStarted Solving the differential equation\nFinished Solving the differential equation\nComputation Time:34.471312284469604\n</pre> In\u00a0[11]: Copied! <pre>start8=time()\nglobal_one=cum.jump_operators(Q1) # Global Jump Operators for Bath 1 \nglobal_two=cum.jump_operators(Q2) # Global Jump Operators for Bath 2\nc_ops_global1=[qt.Qobj((np.sqrt(bath1.power_spectrum(k))*v).data,dims=Hsys.dims) for k, v in global_one.items()]\nc_ops_global2=[qt.Qobj((np.sqrt(bath2.power_spectrum(k))*v).data,dims=Hsys.dims) for k, v in global_two.items()]\nc_ops2=c_ops_global2+c_ops_global1\nresult_lindblad_global2 = qt.mesolve(Hsys, rho0, tlist, c_ops2,options={\"rtol\":1e-12,\"atol\":1e-12})\nend8=time()\n</pre> start8=time() global_one=cum.jump_operators(Q1) # Global Jump Operators for Bath 1  global_two=cum.jump_operators(Q2) # Global Jump Operators for Bath 2 c_ops_global1=[qt.Qobj((np.sqrt(bath1.power_spectrum(k))*v).data,dims=Hsys.dims) for k, v in global_one.items()] c_ops_global2=[qt.Qobj((np.sqrt(bath2.power_spectrum(k))*v).data,dims=Hsys.dims) for k, v in global_two.items()] c_ops2=c_ops_global2+c_ops_global1 result_lindblad_global2 = qt.mesolve(Hsys, rho0, tlist, c_ops2,options={\"rtol\":1e-12,\"atol\":1e-12}) end8=time() In\u00a0[12]: Copied! <pre># LOCAL GKLS SIMULATION\nstart9=time()\noptions = {'nsteps':150000, 'store_states':True,'rtol':1e-12,'atol':1e-12}\nH1_local   = w / 2 * qt.sigmaz() +Delta / 2 * qt.sigmax()\nH2_local   = w / 2 * qt.sigmaz()\nlocal_get1=csolve(Hsys=H1_local,t=0,baths=[],Qs=[],cython=False,matsubara=True)\nlocal_one=local_get1.jump_operators(qt.sigmax())\nlocal_get2=csolve(Hsys=H2_local,t=0,baths=[],Qs=[],cython=False,matsubara=True)\nlocal_two=local_get2.jump_operators(qt.sigmax())\nc_ops_local1=[qt.Qobj((np.sqrt(bath1.power_spectrum(k))*qt.tensor(v,qt.identity(2))).data,dims=Hsys.dims) for k, v in local_one.items()]\nc_ops_local2=[qt.Qobj((np.sqrt(bath2.power_spectrum(k))*qt.tensor(qt.identity(2),v)).data,dims=Hsys.dims) for k, v in local_two.items()]\nc_ops=c_ops_local1+c_ops_local2\nresult_lindblad = qt.mesolve(Hsys, rho0, tlist, c_ops,options=options)\nend9=time()\n</pre> # LOCAL GKLS SIMULATION start9=time() options = {'nsteps':150000, 'store_states':True,'rtol':1e-12,'atol':1e-12} H1_local   = w / 2 * qt.sigmaz() +Delta / 2 * qt.sigmax() H2_local   = w / 2 * qt.sigmaz() local_get1=csolve(Hsys=H1_local,t=0,baths=[],Qs=[],cython=False,matsubara=True) local_one=local_get1.jump_operators(qt.sigmax()) local_get2=csolve(Hsys=H2_local,t=0,baths=[],Qs=[],cython=False,matsubara=True) local_two=local_get2.jump_operators(qt.sigmax()) c_ops_local1=[qt.Qobj((np.sqrt(bath1.power_spectrum(k))*qt.tensor(v,qt.identity(2))).data,dims=Hsys.dims) for k, v in local_one.items()] c_ops_local2=[qt.Qobj((np.sqrt(bath2.power_spectrum(k))*qt.tensor(qt.identity(2),v)).data,dims=Hsys.dims) for k, v in local_two.items()] c_ops=c_ops_local1+c_ops_local2 result_lindblad = qt.mesolve(Hsys, rho0, tlist, c_ops,options=options) end9=time() <p>We now calculate the heat currents</p> In\u00a0[13]: Copied! <pre>j1=np.array([system_heat_current(\"bath 1\",i,Hsys,Q1) for i in result.ado_states])\nj2=np.array([system_heat_current(\"bath 2\",i,Hsys,Q2) for i in result.ado_states])\nsj1=np.array([bath_heat_current(\"bath 1\",i,Hsys,Q1) for i in result.ado_states])\nsj2=np.array([bath_heat_current(\"bath 2\",i,Hsys,Q2) for i in result.ado_states])\nresult_arr=[i.full() for i in result.states]\n</pre> j1=np.array([system_heat_current(\"bath 1\",i,Hsys,Q1) for i in result.ado_states]) j2=np.array([system_heat_current(\"bath 2\",i,Hsys,Q2) for i in result.ado_states]) sj1=np.array([bath_heat_current(\"bath 1\",i,Hsys,Q1) for i in result.ado_states]) sj2=np.array([bath_heat_current(\"bath 2\",i,Hsys,Q2) for i in result.ado_states]) result_arr=[i.full() for i in result.states] In\u00a0[14]: Copied! <pre>j1_cum_ls,j1_red_ls,j1_cum2_ls=master_currents_nm(Hsys,Q1,tlist,bath1corr,result_cum2_ls,result_red_ls,ls=True)\nj1_cum,j1_red,j1_cum2=master_currents_nm(Hsys,Q1,tlist,bath1corr,result_cum2,result_red,ls=False)\n</pre> j1_cum_ls,j1_red_ls,j1_cum2_ls=master_currents_nm(Hsys,Q1,tlist,bath1corr,result_cum2_ls,result_red_ls,ls=True) j1_cum,j1_red,j1_cum2=master_currents_nm(Hsys,Q1,tlist,bath1corr,result_cum2,result_red,ls=False)  <pre>Started integration and Generator Calculations\nFinished integration and Generator Calculations\nComputation Time:9.132726907730103\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nStarted interpolation\nFinished interpolation\nComputation Time:0.01956939697265625\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n</pre> <pre>Calculating Integrals ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81/81 [00:00&lt;00:00, 240.36it/s]\nCalculating time independent matrices...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81/81 [00:00&lt;00:00, 6068.71it/s]\nCalculating time dependent generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81/81 [00:08&lt;00:00,  9.56it/s]\n</pre> <pre>Started integration and Generator Calculations\nFinished integration and Generator Calculations\nComputation Time:5.066476106643677\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nStarted interpolation\nFinished interpolation\nComputation Time:0.01968550682067871\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n</pre> <pre>Calculating Integrals ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81/81 [00:00&lt;00:00, 239.31it/s]\nCalculating time independent matrices...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81/81 [00:00&lt;00:00, 6033.36it/s]\nCalculating time dependent generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81/81 [00:04&lt;00:00, 17.50it/s]\n</pre> In\u00a0[15]: Copied! <pre>j2_cum_ls,j2_red_ls,j2_cum2_ls=master_currents_nm(Hsys,Q2,tlist,bath2corr,result_cum2_ls,result_red_ls,ls=True)\nj2_cum,j2_red,j2_cum2=master_currents_nm(Hsys,Q2,tlist,bath2corr,result_cum2,result_red,ls=False)\n</pre> j2_cum_ls,j2_red_ls,j2_cum2_ls=master_currents_nm(Hsys,Q2,tlist,bath2corr,result_cum2_ls,result_red_ls,ls=True) j2_cum,j2_red,j2_cum2=master_currents_nm(Hsys,Q2,tlist,bath2corr,result_cum2,result_red,ls=False) <pre>Started integration and Generator Calculations\nFinished integration and Generator Calculations\nComputation Time:2.971193313598633\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nStarted interpolation\nFinished interpolation\nComputation Time:0.01986551284790039\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n</pre> <pre>Calculating Integrals ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:00&lt;00:00, 247.89it/s]\nCalculating time independent matrices...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:00&lt;00:00, 5600.47it/s]\nCalculating time dependent generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:02&lt;00:00,  9.87it/s]\n</pre> <pre>Started integration and Generator Calculations\nFinished integration and Generator Calculations\nComputation Time:1.6164255142211914\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nStarted interpolation\nFinished interpolation\nComputation Time:0.01972508430480957\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n</pre> <pre>Calculating Integrals ...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:00&lt;00:00, 249.84it/s]\nCalculating time independent matrices...: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:00&lt;00:00, 5834.50it/s]\nCalculating time dependent generators: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:01&lt;00:00, 18.76it/s]\n</pre> In\u00a0[16]: Copied! <pre>j1_local,j1_global=master_currents(Hsys,c_ops_local1,c_ops_global1,result_lindblad_global2,result_lindblad)\nj2_local,j2_global=master_currents(Hsys,c_ops_local2,c_ops_global2,result_lindblad_global2,result_lindblad)\n</pre> j1_local,j1_global=master_currents(Hsys,c_ops_local1,c_ops_global1,result_lindblad_global2,result_lindblad) j2_local,j2_global=master_currents(Hsys,c_ops_local2,c_ops_global2,result_lindblad_global2,result_lindblad)  <p>Finally we plot the results</p> In\u00a0[17]: Copied! <pre>import matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1.inset_locator import inset_axes\nimport matplotlib.patheffects as pe\n\nfig = plt.figure(figsize=(10, 6))\nplot_ax = fig.add_axes([0.1, 0.1, 0.65, 0.8])  # Main axes\n\n# Main plot\nplot_ax.plot(bath1.lam * tlist, np.array(j2_cum),label=\"Cumulant &amp; Redfield\")\nplot_ax.plot(bath1.lam * tlist, -j2, label=\"HEOM\")\nplot_ax.plot(bath1.lam * tlist, np.array(j2_global),label=\"Global GKLS\",zorder=2)\nplot_ax.plot(bath1.lam * tlist, np.array(j2_cum_ls),\"--\",label=\"Cumulant &amp; Redfield +LS\")\nplot_ax.plot(bath1.lam * tlist, np.array(j2_local),\"-.\",label=\"Local GKLS\",zorder=3)\n\n\nplot_ax.set_xlim(-0.1, 12)\n\nplot_ax.set_xlabel(r\"$\\lambda t$\", fontsize=20)\nplot_ax.set_ylabel(r\"$J_{h}$\", fontsize=20)\n\n\nplot_ax.legend(ncol=1, loc='upper right')\n\nplt.show()\n</pre> import matplotlib.pyplot as plt from mpl_toolkits.axes_grid1.inset_locator import inset_axes import matplotlib.patheffects as pe  fig = plt.figure(figsize=(10, 6)) plot_ax = fig.add_axes([0.1, 0.1, 0.65, 0.8])  # Main axes  # Main plot plot_ax.plot(bath1.lam * tlist, np.array(j2_cum),label=\"Cumulant &amp; Redfield\") plot_ax.plot(bath1.lam * tlist, -j2, label=\"HEOM\") plot_ax.plot(bath1.lam * tlist, np.array(j2_global),label=\"Global GKLS\",zorder=2) plot_ax.plot(bath1.lam * tlist, np.array(j2_cum_ls),\"--\",label=\"Cumulant &amp; Redfield +LS\") plot_ax.plot(bath1.lam * tlist, np.array(j2_local),\"-.\",label=\"Local GKLS\",zorder=3)   plot_ax.set_xlim(-0.1, 12)  plot_ax.set_xlabel(r\"$\\lambda t$\", fontsize=20) plot_ax.set_ylabel(r\"$J_{h}$\", fontsize=20)   plot_ax.legend(ncol=1, loc='upper right')  plt.show()  <pre>/home/Gerardo/anaconda3/envs/qutip-dev/lib/python3.11/site-packages/matplotlib/cbook/__init__.py:1335: ComplexWarning: Casting complex values to real discards the imaginary part\n  return np.asarray(x, float)\n</pre> In\u00a0[18]: Copied! <pre>fig = plt.figure(figsize=(10, 6))\nplot_ax = fig.add_axes([0.1, 0.1, 0.65, 0.8])  # Main axes\n\n# Main plot\nplot_ax.plot(bath1.lam * tlist, np.array(j2_cum)+np.array(j1_cum),label=\"Cumulant &amp; Redfield\")\nplot_ax.plot(bath1.lam * tlist, -(j2+j1), label=\"HEOM\")\nplot_ax.plot(bath1.lam * tlist, np.array(j2_global)+np.array(j1_global),label=\"Global GKLS\",zorder=2)\nplot_ax.plot(bath1.lam * tlist, np.array(j2_cum_ls)+np.array(j1_cum_ls),\"--\",label=\"Cumulant &amp; Redfield +LS\")\nplot_ax.plot(bath1.lam * tlist, np.array(j2_local)+np.array(j1_local),marker=\"x\",linestyle='None'\n             ,label=\"Local GKLS\",zorder=6,markevery=20,markeredgewidth=3)\n\nplot_ax.set_xlim(-0.1, 12)\n\nplot_ax.set_xlabel(r\"$\\alpha t$\", fontsize=20)\nplot_ax.set_ylabel(r\"$Q$\", fontsize=20)\n\nplot_ax.legend(ncol=1, loc='upper right')\n\nplt.show()\n</pre> fig = plt.figure(figsize=(10, 6)) plot_ax = fig.add_axes([0.1, 0.1, 0.65, 0.8])  # Main axes  # Main plot plot_ax.plot(bath1.lam * tlist, np.array(j2_cum)+np.array(j1_cum),label=\"Cumulant &amp; Redfield\") plot_ax.plot(bath1.lam * tlist, -(j2+j1), label=\"HEOM\") plot_ax.plot(bath1.lam * tlist, np.array(j2_global)+np.array(j1_global),label=\"Global GKLS\",zorder=2) plot_ax.plot(bath1.lam * tlist, np.array(j2_cum_ls)+np.array(j1_cum_ls),\"--\",label=\"Cumulant &amp; Redfield +LS\") plot_ax.plot(bath1.lam * tlist, np.array(j2_local)+np.array(j1_local),marker=\"x\",linestyle='None'              ,label=\"Local GKLS\",zorder=6,markevery=20,markeredgewidth=3)  plot_ax.set_xlim(-0.1, 12)  plot_ax.set_xlabel(r\"$\\alpha t$\", fontsize=20) plot_ax.set_ylabel(r\"$Q$\", fontsize=20)  plot_ax.legend(ncol=1, loc='upper right')  plt.show() In\u00a0[20]: Copied! <pre>fig = plt.figure(figsize=(10, 6))\nplot_ax = fig.add_axes([0.1, 0.1, 0.65, 0.8])  # Main axes\n\nfid_global=[qt.fidelity(result.states[i],qt.Qobj(result_lindblad_global2.states[i])) for i in range(len(tlist))]\nfid_cum=[qt.fidelity(result.states[i],qt.Qobj(result_cum2_ls[i],dims=Hsys.dims)) for i in range(len(tlist))]\nfid_red=[qt.fidelity(result.states[i],qt.Qobj(result_red_ls[i],dims=Hsys.dims)) for i in range(len(tlist))]\n\nfid_local=[qt.fidelity(result.states[i],qt.Qobj(result_lindblad.states[i])) for i in range(len(tlist))]\n\nplot_ax.plot(bath1.lam*tlist,fid_red,label=\"Redfield+LS\")\nplot_ax.plot([], [], visible=False)\nplot_ax.plot(bath1.lam*tlist,fid_global,label=\"Global\",zorder=1)\nplot_ax.plot(bath1.lam*tlist,fid_cum,\"--\",label=\"Cumulant+LS\")\nplot_ax.plot(bath1.lam*tlist,fid_local,label=\"Local\",linestyle=\"None\",marker='o',markevery=20)\nplot_ax.set_xlabel(r\"$\\lambda t$\", fontsize=20)\nplot_ax.set_ylabel(r\"$\\mathcal{F}(\\rho)$\", fontsize=20)\n# plt.xlim(-1,50)\n# plt.ylim(0.995,1.0001)\nplot_ax.legend(ncol=1, loc='center right')\nplt.show()\n</pre> fig = plt.figure(figsize=(10, 6)) plot_ax = fig.add_axes([0.1, 0.1, 0.65, 0.8])  # Main axes  fid_global=[qt.fidelity(result.states[i],qt.Qobj(result_lindblad_global2.states[i])) for i in range(len(tlist))] fid_cum=[qt.fidelity(result.states[i],qt.Qobj(result_cum2_ls[i],dims=Hsys.dims)) for i in range(len(tlist))] fid_red=[qt.fidelity(result.states[i],qt.Qobj(result_red_ls[i],dims=Hsys.dims)) for i in range(len(tlist))]  fid_local=[qt.fidelity(result.states[i],qt.Qobj(result_lindblad.states[i])) for i in range(len(tlist))]  plot_ax.plot(bath1.lam*tlist,fid_red,label=\"Redfield+LS\") plot_ax.plot([], [], visible=False) plot_ax.plot(bath1.lam*tlist,fid_global,label=\"Global\",zorder=1) plot_ax.plot(bath1.lam*tlist,fid_cum,\"--\",label=\"Cumulant+LS\") plot_ax.plot(bath1.lam*tlist,fid_local,label=\"Local\",linestyle=\"None\",marker='o',markevery=20) plot_ax.set_xlabel(r\"$\\lambda t$\", fontsize=20) plot_ax.set_ylabel(r\"$\\mathcal{F}(\\rho)$\", fontsize=20) # plt.xlim(-1,50) # plt.ylim(0.995,1.0001) plot_ax.legend(ncol=1, loc='center right') plt.show() In\u00a0[23]: Copied! <pre>methods2=[\"Cumulant\",\"Redfield\"]\nplt.bar(methods2, np.array([end3-start3,end7-start7]),color=\"orange\")\nmethods2=[\"HEOM\",\"Cumulant\",\"Redfield\"]\nplt.bar(methods2, [end_heom-start,end2-start2,end5-start5])\nplt.yscale(\"log\")\nplt.ylabel(r\"$\\log(\\tau)$\",fontsize=15)\nplt.savefig(\"example2_timing.pdf\", bbox_inches='tight')\nplt.show()\n</pre> methods2=[\"Cumulant\",\"Redfield\"] plt.bar(methods2, np.array([end3-start3,end7-start7]),color=\"orange\") methods2=[\"HEOM\",\"Cumulant\",\"Redfield\"] plt.bar(methods2, [end_heom-start,end2-start2,end5-start5]) plt.yscale(\"log\") plt.ylabel(r\"$\\log(\\tau)$\",fontsize=15) plt.savefig(\"example2_timing.pdf\", bbox_inches='tight') plt.show()"},{"location":"transport_example/#example-3-heat-transport-in-a-two-qubit-machine-with-underdamped-enviroments","title":"Example 3:  Heat transport in a two qubit machine with underdamped enviroments\u00b6","text":"<p>This example provides the necessary code to reproduce the calculations from example 2 in 2, where the Hamiltonian is given by</p> <p>\\begin{align}      H &amp;= \\underbrace{\\frac{\\omega_{c}}{2} \\sigma^{(c)}_{z} + \\frac{\\Delta}{2} \\sigma^{(c)}_{x}      +\\frac{\\omega_{h}}{2} \\sigma^{(h)}_{z}       + g \\sigma^{(c)}_{x} \\sigma^{(h)}_{x}}_{H_S} + \\underbrace{\\sum_{k,\\alpha=h,c} \\omega^{(\\alpha)}_{k} a_{k}^{(\\alpha)\\dagger} a^{(\\alpha)}_{k}}_{H_B}       + \\underbrace{\\sum_{k,\\alpha=h,c} g_k \\sigma^{(\\alpha)}_{x} (a_{k}+a_{k}^{\\dagger})}_{H_I}. \\end{align}</p> <p>We first begin by importing the necessary packages</p>"},{"location":"tutorial/","title":"Under construction","text":""}]}